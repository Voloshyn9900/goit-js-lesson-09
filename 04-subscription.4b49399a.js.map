{"mappings":"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","sources":["node_modules/bootstrap.native/node_modules/@thednp/shorty/dist/shorty.mjs","node_modules/bootstrap.native/node_modules/@thednp/event-listener/dist/event-listener.mjs","node_modules/bootstrap.native/src/components/base-component.ts","node_modules/bootstrap.native/src/strings/alertComponent.ts","node_modules/bootstrap.native/src/components/alert.ts","node_modules/bootstrap.native/src/strings/showClass.ts","node_modules/bootstrap.native/src/strings/fadeClass.ts","node_modules/bootstrap.native/src/strings/activeClass.ts","node_modules/bootstrap.native/src/components/button.ts","node_modules/bootstrap.native/src/strings/buttonComponent.ts","node_modules/bootstrap.native/src/strings/dataBsTarget.ts","node_modules/bootstrap.native/src/util/getTargetElement.ts","node_modules/bootstrap.native/src/strings/dataBsParent.ts","node_modules/bootstrap.native/src/strings/dataBsContainer.ts","node_modules/bootstrap.native/src/components/carousel.ts","node_modules/bootstrap.native/src/strings/carouselComponent.ts","node_modules/bootstrap.native/src/strings/carouselString.ts","node_modules/bootstrap.native/src/strings/collapsingClass.ts","node_modules/bootstrap.native/src/components/collapse.ts","node_modules/bootstrap.native/src/strings/collapseComponent.ts","node_modules/bootstrap.native/src/strings/collapseString.ts","node_modules/bootstrap.native/src/strings/dropdownClasses.ts","node_modules/bootstrap.native/src/util/isEmptyAnchor.ts","node_modules/bootstrap.native/src/components/dropdown.ts","node_modules/bootstrap.native/src/strings/dropdownComponent.ts","node_modules/bootstrap.native/src/strings/dataBsToggle.ts","node_modules/bootstrap.native/src/strings/dropdownMenuClass.ts","node_modules/bootstrap.native/src/strings/modalString.ts","node_modules/bootstrap.native/src/strings/stickyTopClass.ts","node_modules/bootstrap.native/src/strings/positionStickyClass.ts","node_modules/bootstrap.native/src/util/scrollbar.ts","node_modules/bootstrap.native/src/strings/fixedTopClass.ts","node_modules/bootstrap.native/src/strings/fixedBottomClass.ts","node_modules/bootstrap.native/src/util/popupContainer.ts","node_modules/bootstrap.native/src/util/backdrop.ts","node_modules/bootstrap.native/src/util/isVisible.ts","node_modules/bootstrap.native/src/components/modal.ts","node_modules/bootstrap.native/src/strings/modalComponent.ts","node_modules/bootstrap.native/src/strings/offcanvasComponent.ts","node_modules/bootstrap.native/src/components/offcanvas.ts","node_modules/bootstrap.native/src/strings/popoverString.ts","node_modules/bootstrap.native/src/util/getTipTemplate.ts","node_modules/bootstrap.native/src/strings/tooltipString.ts","node_modules/bootstrap.native/src/util/tipClassPositions.ts","node_modules/bootstrap.native/src/util/styleTip.ts","node_modules/bootstrap.native/src/strings/popoverComponent.ts","node_modules/bootstrap.native/src/util/tooltipDefaults.ts","node_modules/bootstrap.native/src/util/setHtml.ts","node_modules/bootstrap.native/src/components/tooltip.ts","node_modules/bootstrap.native/src/strings/tooltipComponent.ts","node_modules/bootstrap.native/src/strings/dataOriginalTitle.ts","node_modules/bootstrap.native/src/util/getElementContainer.ts","node_modules/bootstrap.native/src/util/createTip.ts","node_modules/bootstrap.native/src/components/popover.ts","node_modules/bootstrap.native/src/strings/scrollspyString.ts","node_modules/bootstrap.native/src/components/scrollspy.ts","node_modules/bootstrap.native/src/strings/scrollspyComponent.ts","node_modules/bootstrap.native/src/strings/tabString.ts","node_modules/bootstrap.native/src/components/tab.ts","node_modules/bootstrap.native/src/strings/tabComponent.ts","node_modules/bootstrap.native/src/strings/toastString.ts","node_modules/bootstrap.native/src/components/toast.ts","node_modules/bootstrap.native/src/strings/toastComponent.ts","node_modules/bootstrap.native/src/util/init.ts","src/js/04-subscription.js"],"sourcesContent":["const pe = \"aria-checked\", fe = \"aria-description\", me = \"aria-describedby\", ge = \"aria-expanded\", ve = \"aria-haspopup\", Ee = \"aria-hidden\", be = \"aria-label\", he = \"aria-labelledby\", ye = \"aria-modal\", we = \"aria-pressed\", Ae = \"aria-selected\", Se = \"aria-valuemin\", Me = \"aria-valuemax\", Ne = \"aria-valuenow\", ke = \"aria-valuetext\", G = \"abort\", j = \"beforeunload\", J = \"blur\", K = \"change\", X = \"contextmenu\", P = \"DOMContentLoaded\", Y = \"DOMMouseScroll\", Z = \"error\", $ = \"focus\", _ = \"focusin\", tt = \"focusout\", et = \"gesturechange\", nt = \"gestureend\", ot = \"gesturestart\", st = \"keydown\", ct = \"keypress\", rt = \"keyup\", at = \"load\", it = \"click\", ut = \"dblclick\", lt = \"mousedown\", dt = \"mouseup\", pt = \"hover\", ft = \"mouseenter\", mt = \"mouseleave\", gt = \"mousein\", vt = \"mouseout\", Et = \"mouseover\", bt = \"mousemove\", ht = \"mousewheel\", yt = \"move\", wt = \"orientationchange\", At = \"pointercancel\", St = \"pointerdown\", Mt = \"pointerleave\", Nt = \"pointermove\", kt = \"pointerup\", Tt = \"readystatechange\", Dt = \"reset\", Ct = \"resize\", Lt = \"select\", Ot = \"selectend\", It = \"selectstart\", zt = \"scroll\", xt = \"submit\", Vt = \"touchstart\", Bt = \"touchmove\", Ht = \"touchcancel\", Pt = \"touchend\", Ut = \"unload\", Te = {\n  DOMContentLoaded: P,\n  DOMMouseScroll: Y,\n  abort: G,\n  beforeunload: j,\n  blur: J,\n  change: K,\n  click: it,\n  contextmenu: X,\n  dblclick: ut,\n  error: Z,\n  focus: $,\n  focusin: _,\n  focusout: tt,\n  gesturechange: et,\n  gestureend: nt,\n  gesturestart: ot,\n  hover: pt,\n  keydown: st,\n  keypress: ct,\n  keyup: rt,\n  load: at,\n  mousedown: lt,\n  mousemove: bt,\n  mousein: gt,\n  mouseout: vt,\n  mouseenter: ft,\n  mouseleave: mt,\n  mouseover: Et,\n  mouseup: dt,\n  mousewheel: ht,\n  move: yt,\n  orientationchange: wt,\n  pointercancel: At,\n  pointerdown: St,\n  pointerleave: Mt,\n  pointermove: Nt,\n  pointerup: kt,\n  readystatechange: Tt,\n  reset: Dt,\n  resize: Ct,\n  scroll: zt,\n  select: Lt,\n  selectend: Ot,\n  selectstart: It,\n  submit: xt,\n  touchcancel: Ht,\n  touchend: Pt,\n  touchmove: Bt,\n  touchstart: Vt,\n  unload: Ut\n}, De = \"drag\", Ce = \"dragstart\", Le = \"dragenter\", Oe = \"dragleave\", Ie = \"dragover\", ze = \"dragend\", xe = \"loadstart\", Ve = {\n  start: \"mousedown\",\n  end: \"mouseup\",\n  move: \"mousemove\",\n  cancel: \"mouseleave\"\n}, Be = { down: \"mousedown\", up: \"mouseup\" }, He = \"onmouseleave\" in document ? [\"mouseenter\", \"mouseleave\"] : (\n  /* istanbul ignore next */\n  [\"mouseover\", \"mouseout\"]\n), Pe = {\n  start: \"touchstart\",\n  end: \"touchend\",\n  move: \"touchmove\",\n  cancel: \"touchcancel\"\n}, Ue = { in: \"focusin\", out: \"focusout\" }, Fe = {\n  Backspace: \"Backspace\",\n  //  8\n  Tab: \"Tab\",\n  //  9\n  Enter: \"Enter\",\n  // 13\n  Shift: \"Shift\",\n  // 16\n  Control: \"Control\",\n  // 17\n  Alt: \"Alt\",\n  // 18\n  Pause: \"Pause\",\n  // 19\n  CapsLock: \"CapsLock\",\n  // 20\n  Escape: \"Escape\",\n  // 27\n  Scape: \"Space\",\n  // 32\n  ArrowLeft: \"ArrowLeft\",\n  // 37\n  ArrowUp: \"ArrowUp\",\n  // 38\n  ArrowRight: \"ArrowRight\",\n  // 39\n  ArrowDown: \"ArrowDown\",\n  // 40\n  Insert: \"Insert\",\n  // 45\n  Delete: \"Delete\",\n  // 46\n  Meta: \"Meta\",\n  // 91 windows key\n  ContextMenu: \"ContextMenu\",\n  // 93\n  ScrollLock: \"ScrollLock\"\n  // 145\n}, We = \"Alt\", Re = \"ArrowDown\", Qe = \"ArrowUp\", qe = \"ArrowLeft\", Ge = \"ArrowRight\", je = \"Backspace\", Je = \"CapsLock\", Ke = \"Control\", Xe = \"Delete\", Ye = \"Enter\", Ze = \"Escape\", $e = \"Insert\", _e = \"Meta\", tn = \"Pause\", en = \"ScrollLock\", nn = \"Shift\", on = \"Space\", sn = \"Tab\", Ft = \"animationDuration\", Wt = \"animationDelay\", U = \"animationName\", D = \"animationend\", Rt = \"transitionDuration\", Qt = \"transitionDelay\", C = \"transitionend\", F = \"transitionProperty\", cn = \"addEventListener\", rn = \"removeEventListener\", an = {\n  linear: \"linear\",\n  easingSinusoidalIn: \"cubic-bezier(0.47,0,0.745,0.715)\",\n  easingSinusoidalOut: \"cubic-bezier(0.39,0.575,0.565,1)\",\n  easingSinusoidalInOut: \"cubic-bezier(0.445,0.05,0.55,0.95)\",\n  easingQuadraticIn: \"cubic-bezier(0.550,0.085,0.680,0.530)\",\n  easingQuadraticOut: \"cubic-bezier(0.250,0.460,0.450,0.940)\",\n  easingQuadraticInOut: \"cubic-bezier(0.455,0.030,0.515,0.955)\",\n  easingCubicIn: \"cubic-bezier(0.55,0.055,0.675,0.19)\",\n  easingCubicOut: \"cubic-bezier(0.215,0.61,0.355,1)\",\n  easingCubicInOut: \"cubic-bezier(0.645,0.045,0.355,1)\",\n  easingQuarticIn: \"cubic-bezier(0.895,0.03,0.685,0.22)\",\n  easingQuarticOut: \"cubic-bezier(0.165,0.84,0.44,1)\",\n  easingQuarticInOut: \"cubic-bezier(0.77,0,0.175,1)\",\n  easingQuinticIn: \"cubic-bezier(0.755,0.05,0.855,0.06)\",\n  easingQuinticOut: \"cubic-bezier(0.23,1,0.32,1)\",\n  easingQuinticInOut: \"cubic-bezier(0.86,0,0.07,1)\",\n  easingExponentialIn: \"cubic-bezier(0.95,0.05,0.795,0.035)\",\n  easingExponentialOut: \"cubic-bezier(0.19,1,0.22,1)\",\n  easingExponentialInOut: \"cubic-bezier(1,0,0,1)\",\n  easingCircularIn: \"cubic-bezier(0.6,0.04,0.98,0.335)\",\n  easingCircularOut: \"cubic-bezier(0.075,0.82,0.165,1)\",\n  easingCircularInOut: \"cubic-bezier(0.785,0.135,0.15,0.86)\",\n  easingBackIn: \"cubic-bezier(0.6,-0.28,0.735,0.045)\",\n  easingBackOut: \"cubic-bezier(0.175,0.885,0.32,1.275)\",\n  easingBackInOut: \"cubic-bezier(0.68,-0.55,0.265,1.55)\"\n}, un = \"offsetHeight\", ln = \"offsetWidth\", dn = \"scrollHeight\", pn = \"scrollWidth\", fn = \"tabindex\", qt = navigator.userAgentData, A = qt, { userAgent: Gt } = navigator, S = Gt, z = /iPhone|iPad|iPod|Android/i;\nlet L = !1;\nA ? L = A.brands.some((t) => z.test(t.brand)) : L = z.test(S);\nconst mn = L, x = /(iPhone|iPod|iPad)/, gn = A ? A.brands.some((t) => x.test(t.brand)) : (\n  /* istanbul ignore next */\n  x.test(S)\n), vn = S ? S.includes(\"Firefox\") : (\n  /* istanbul ignore next */\n  !1\n), { head: M } = document, En = [\"webkitPerspective\", \"perspective\"].some((t) => t in M.style), jt = (t, e, n, o) => {\n  const s = o || !1;\n  t.addEventListener(e, n, s);\n}, Jt = (t, e, n, o) => {\n  const s = o || !1;\n  t.removeEventListener(e, n, s);\n}, Kt = (t, e, n, o) => {\n  const s = (r) => {\n    (r.target === t || r.currentTarget === t) && (n.apply(t, [r]), Jt(t, e, s, o));\n  };\n  jt(t, e, s, o);\n}, Xt = () => {\n}, bn = (() => {\n  let t = !1;\n  try {\n    const e = Object.defineProperty({}, \"passive\", {\n      get: () => (t = !0, t)\n    });\n    Kt(document, P, Xt, e);\n  } catch {\n  }\n  return t;\n})(), hn = [\"webkitTransform\", \"transform\"].some((t) => t in M.style), yn = \"ontouchstart\" in window || /* istanbul ignore next */\n\"msMaxTouchPoints\" in navigator, wn = [\"webkitAnimation\", \"animation\"].some((t) => t in M.style), An = [\"webkitTransition\", \"transition\"].some((t) => t in M.style), Yt = (t, e) => t.getAttribute(e), Sn = (t, e, n) => e.getAttributeNS(t, n), Mn = (t, e) => t.hasAttribute(e), Nn = (t, e, n) => e.hasAttributeNS(t, n), kn = (t, e, n) => t.setAttribute(e, n), Tn = (t, e, n, o) => e.setAttributeNS(t, n, o), Dn = (t, e) => t.removeAttribute(e), Cn = (t, e, n) => e.removeAttributeNS(t, n), Ln = (t, ...e) => {\n  t.classList.add(...e);\n}, On = (t, ...e) => {\n  t.classList.remove(...e);\n}, In = (t, e) => t.classList.contains(e), { body: zn } = document, { documentElement: xn } = document, Vn = (t) => Array.from(t), v = (t) => t != null && typeof t == \"object\" || !1, i = (t) => v(t) && typeof t.nodeType == \"number\" && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].some((e) => t.nodeType === e) || !1, u = (t) => i(t) && t.nodeType === 1 || !1, E = /* @__PURE__ */ new Map(), O = {\n  data: E,\n  /**\n   * Sets web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @param instance the component instance\n   */\n  set: (t, e, n) => {\n    if (!u(t))\n      return;\n    E.has(e) || E.set(e, /* @__PURE__ */ new Map()), E.get(e).set(t, n);\n  },\n  /**\n   * Returns all instances for specified component.\n   *\n   * @param component the component's name or a unique key\n   * @returns all the component instances\n   */\n  getAllFor: (t) => E.get(t) || null,\n  /**\n   * Returns the instance associated with the target.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @returns the instance\n   */\n  get: (t, e) => {\n    if (!u(t) || !e)\n      return null;\n    const n = O.getAllFor(e);\n    return t && n && n.get(t) || null;\n  },\n  /**\n   * Removes web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   */\n  remove: (t, e) => {\n    const n = O.getAllFor(e);\n    !n || !u(t) || (n.delete(t), n.size === 0 && E.delete(e));\n  }\n}, Bn = (t, e) => O.get(t, e), N = (t) => typeof t == \"string\" || !1, W = (t) => v(t) && t.constructor.name === \"Window\" || !1, R = (t) => i(t) && t.nodeType === 9 || !1, d = (t) => W(t) ? t.document : R(t) ? t : i(t) ? t.ownerDocument : window.document, k = (t, ...e) => Object.assign(t, ...e), Zt = (t) => {\n  if (!t)\n    return;\n  if (N(t))\n    return d().createElement(t);\n  const { tagName: e } = t, n = Zt(e);\n  if (!n)\n    return;\n  const o = { ...t };\n  return delete o.tagName, k(n, o);\n}, $t = (t, e) => {\n  if (!t || !e)\n    return;\n  if (N(e))\n    return d().createElementNS(t, e);\n  const { tagName: n } = e, o = $t(t, n);\n  if (!o)\n    return;\n  const s = { ...e };\n  return delete s.tagName, k(o, s);\n}, Q = (t, e) => t.dispatchEvent(e), Hn = (t, e, n) => n.indexOf(t) === e, g = (t, e) => {\n  const n = getComputedStyle(t), o = e.replace(\"webkit\", \"Webkit\").replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  return n.getPropertyValue(o);\n}, _t = (t) => {\n  const e = g(t, U), n = g(t, Wt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, te = (t) => {\n  const e = g(t, U), n = g(t, Ft), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, Pn = (t, e) => {\n  let n = 0;\n  const o = new Event(D), s = te(t), r = _t(t);\n  if (s) {\n    const a = (l) => {\n      l.target === t && (e.apply(t, [l]), t.removeEventListener(D, a), n = 1);\n    };\n    t.addEventListener(D, a), setTimeout(() => {\n      n || Q(t, o);\n    }, s + r + 17);\n  } else\n    e.apply(t, [o]);\n}, ee = (t) => {\n  const e = g(t, F), n = g(t, Qt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, ne = (t) => {\n  const e = g(t, F), n = g(t, Rt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, Un = (t, e) => {\n  let n = 0;\n  const o = new Event(C), s = ne(t), r = ee(t);\n  if (s) {\n    const a = (l) => {\n      l.target === t && (e.apply(t, [l]), t.removeEventListener(C, a), n = 1);\n    };\n    t.addEventListener(C, a), setTimeout(() => {\n      n || Q(t, o);\n    }, s + r + 17);\n  } else\n    e.apply(t, [o]);\n}, Fn = (t) => Float32Array.from(Array.from(t)), Wn = (t) => Float64Array.from(Array.from(t)), Rn = (t, e) => t.focus(e), V = (t) => [\"true\", !0].includes(t) ? !0 : [\"false\", !1].includes(t) ? !1 : [\"null\", \"\", null, void 0].includes(t) ? null : t !== \"\" && !Number.isNaN(+t) ? +t : t, w = (t) => Object.entries(t), oe = (t) => t.toLowerCase(), Qn = (t, e, n, o) => {\n  const s = { ...n }, r = { ...t.dataset }, a = { ...e }, l = {}, p = \"title\";\n  return w(r).forEach(([c, f]) => {\n    const y = o && typeof c == \"string\" && c.includes(o) ? c.replace(o, \"\").replace(/[A-Z]/g, (q) => oe(q)) : c;\n    l[y] = V(f);\n  }), w(s).forEach(([c, f]) => {\n    s[c] = V(f);\n  }), w(e).forEach(([c, f]) => {\n    c in s ? a[c] = s[c] : c in l ? a[c] = l[c] : a[c] = c === p ? Yt(t, p) : f;\n  }), a;\n}, qn = (t, e) => v(t) && (Object.hasOwn(t, e) || e in t), Gn = (t) => Object.keys(t), jn = (t) => Object.values(t), Jn = (t, e) => {\n  const n = new CustomEvent(t, {\n    cancelable: !0,\n    bubbles: !0\n  });\n  return v(e) && k(n, e), n;\n}, Kn = { passive: !0 }, Xn = (t) => t.offsetHeight, Yn = (t, e) => {\n  w(e).forEach(([n, o]) => {\n    if (o && N(n) && n.includes(\"--\"))\n      t.style.setProperty(n, o);\n    else {\n      const s = {};\n      s[n] = o, k(t.style, s);\n    }\n  });\n}, I = (t) => v(t) && t.constructor.name === \"Map\" || !1, se = (t) => typeof t == \"number\" || !1, m = /* @__PURE__ */ new Map(), Zn = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   *\n   * @param element target element\n   * @param callback the callback\n   * @param delay the execution delay\n   * @param key a unique key\n   */\n  set: (t, e, n, o) => {\n    u(t) && (o && o.length ? (m.has(t) || m.set(t, /* @__PURE__ */ new Map()), m.get(t).set(o, setTimeout(e, n))) : m.set(t, setTimeout(e, n)));\n  },\n  /**\n   * Returns the timer associated with the target.\n   *\n   * @param element target element\n   * @param key a unique\n   * @returns the timer\n   */\n  get: (t, e) => {\n    if (!u(t))\n      return null;\n    const n = m.get(t);\n    return e && n && I(n) ? n.get(e) || /* istanbul ignore next */\n    null : se(n) ? n : null;\n  },\n  /**\n   * Clears the element's timer.\n   *\n   * @param element target element\n   * @param key a unique key\n   */\n  clear: (t, e) => {\n    if (!u(t))\n      return;\n    const n = m.get(t);\n    e && e.length && I(n) ? (clearTimeout(n.get(e)), n.delete(e), n.size === 0 && m.delete(t)) : (clearTimeout(n), m.delete(t));\n  }\n}, $n = (t) => t.toUpperCase(), h = (t, e) => {\n  const { width: n, height: o, top: s, right: r, bottom: a, left: l } = t.getBoundingClientRect();\n  let p = 1, c = 1;\n  if (e && u(t)) {\n    const { offsetWidth: f, offsetHeight: y } = t;\n    p = f > 0 ? Math.round(n) / f : (\n      /* istanbul ignore next */\n      1\n    ), c = y > 0 ? Math.round(o) / y : (\n      /* istanbul ignore next */\n      1\n    );\n  }\n  return {\n    width: n / p,\n    height: o / c,\n    top: s / c,\n    right: r / p,\n    bottom: a / c,\n    left: l / p,\n    x: l / p,\n    y: s / c\n  };\n}, _n = (t) => d(t).body, T = (t) => d(t).documentElement, to = (t) => d(t).head, eo = (t) => {\n  const e = W(t), n = e ? t.scrollX : t.scrollLeft, o = e ? t.scrollY : t.scrollTop;\n  return { x: n, y: o };\n}, ce = (t) => i(t) && t.constructor.name === \"ShadowRoot\" || !1, no = (t) => t.nodeName === \"HTML\" ? t : u(t) && t.assignedSlot || // step into the shadow DOM of the parent of a slotted node\ni(t) && t.parentNode || // DOM Element detected\nce(t) && t.host || // ShadowRoot detected\nT(t), re = (t) => {\n  if (!u(t))\n    return !1;\n  const { width: e, height: n } = h(t), { offsetWidth: o, offsetHeight: s } = t;\n  return Math.round(e) !== o || Math.round(n) !== s;\n}, oo = (t, e, n) => {\n  const o = u(e), s = h(t, o && re(e)), r = { x: 0, y: 0 };\n  if (o) {\n    const a = h(e, !0);\n    r.x = a.x + e.clientLeft, r.y = a.y + e.clientTop;\n  }\n  return {\n    x: s.left + n.x - r.x,\n    y: s.top + n.y - r.y,\n    width: s.width,\n    height: s.height\n  };\n};\nlet B = 0, H = 0;\nconst b = /* @__PURE__ */ new Map(), ae = (t, e) => {\n  let n = e ? B : H;\n  if (e) {\n    const o = ae(t), s = b.get(o) || /* @__PURE__ */ new Map();\n    b.has(o) || b.set(o, s), I(s) && !s.has(e) ? (s.set(e, n), B += 1) : n = s.get(e);\n  } else {\n    const o = t.id || t;\n    b.has(o) ? n = b.get(o) : (b.set(o, n), H += 1);\n  }\n  return n;\n}, so = (t) => {\n  var e;\n  return t ? R(t) ? t.defaultView : i(t) ? (e = t == null ? void 0 : t.ownerDocument) == null ? void 0 : e.defaultView : t : window;\n}, ie = (t) => Array.isArray(t) || !1, co = (t) => i(t) && t.nodeName === \"CANVAS\" || !1, ue = (t) => u(t) && !!t.shadowRoot || !1, ro = (t) => i(t) && [1, 2, 3, 4, 5, 6, 7, 8].some((e) => t.nodeType === e) || !1, ao = (t) => {\n  if (!i(t))\n    return !1;\n  const { top: e, bottom: n } = h(t), { clientHeight: o } = T(t);\n  return e <= o && n >= 0;\n}, io = (t) => {\n  if (!i(t))\n    return !1;\n  const { clientWidth: e, clientHeight: n } = T(t), { top: o, left: s, bottom: r, right: a } = h(t, !0);\n  return o >= 0 && s >= 0 && r <= n && a <= e;\n}, uo = (t) => ie(t) && t.every(u) || !1, lo = (t) => typeof t == \"function\" || !1, po = (t) => v(t) && t.constructor.name === \"HTMLCollection\" || !1, fo = (t) => u(t) && t.tagName === \"IMG\" || !1, mo = (t) => {\n  if (!N(t))\n    return !1;\n  try {\n    JSON.parse(t);\n  } catch {\n    return !1;\n  }\n  return !0;\n}, go = (t) => v(t) && t.constructor.name === \"WeakMap\" || !1, vo = (t) => i(t) && [\"SVG\", \"Image\", \"Video\", \"Canvas\"].some((e) => t.constructor.name.includes(e)) || !1, Eo = (t) => v(t) && t.constructor.name === \"NodeList\" || !1, bo = (t) => T(t).dir === \"rtl\", ho = (t) => i(t) && t.constructor.name.includes(\"SVG\") || !1, yo = (t) => i(t) && [\"TABLE\", \"TD\", \"TH\"].includes(t.nodeName) || !1, le = (t, e) => t ? t.closest(e) || // break out of `ShadowRoot`\nle(t.getRootNode().host, e) : null, wo = (t, e) => u(t) ? t : (i(e) ? e : d()).querySelector(t), de = (t, e) => (i(e) ? e : d()).getElementsByTagName(t), Ao = (t) => [...de(\"*\", t)].filter(ue), So = (t, e) => d(e).getElementById(t) || null, Mo = (t, e) => (i(e) ? e : d()).querySelectorAll(t), No = (t, e) => (e && i(e) ? e : d()).getElementsByClassName(\n  t\n), ko = (t, e) => t.matches(e), To = \"2.0.0alpha16\";\nexport {\n  Vn as ArrayFrom,\n  P as DOMContentLoadedEvent,\n  Y as DOMMouseScrollEvent,\n  O as Data,\n  Fn as Float32ArrayFrom,\n  Wn as Float64ArrayFrom,\n  k as ObjectAssign,\n  w as ObjectEntries,\n  qn as ObjectHasOwn,\n  Gn as ObjectKeys,\n  jn as ObjectValues,\n  Zn as Timer,\n  G as abortEvent,\n  Ln as addClass,\n  cn as addEventListener,\n  Wt as animationDelay,\n  Ft as animationDuration,\n  D as animationEndEvent,\n  U as animationName,\n  pe as ariaChecked,\n  me as ariaDescribedBy,\n  fe as ariaDescription,\n  ge as ariaExpanded,\n  ve as ariaHasPopup,\n  Ee as ariaHidden,\n  be as ariaLabel,\n  he as ariaLabelledBy,\n  ye as ariaModal,\n  we as ariaPressed,\n  Ae as ariaSelected,\n  Me as ariaValueMax,\n  Se as ariaValueMin,\n  Ne as ariaValueNow,\n  ke as ariaValueText,\n  j as beforeunloadEvent,\n  an as bezierEasings,\n  J as blurEvent,\n  K as changeEvent,\n  le as closest,\n  X as contextmenuEvent,\n  Jn as createCustomEvent,\n  Zt as createElement,\n  $t as createElementNS,\n  Q as dispatchEvent,\n  Hn as distinct,\n  zn as documentBody,\n  xn as documentElement,\n  M as documentHead,\n  De as dragEvent,\n  ze as dragendEvent,\n  Le as dragenterEvent,\n  Oe as dragleaveEvent,\n  Ie as dragoverEvent,\n  Ce as dragstartEvent,\n  Pn as emulateAnimationEnd,\n  Un as emulateTransitionEnd,\n  Z as errorEvent,\n  Rn as focus,\n  $ as focusEvent,\n  Ue as focusEvents,\n  _ as focusinEvent,\n  tt as focusoutEvent,\n  et as gesturechangeEvent,\n  nt as gestureendEvent,\n  ot as gesturestartEvent,\n  Yt as getAttribute,\n  Sn as getAttributeNS,\n  h as getBoundingClientRect,\n  Ao as getCustomElements,\n  d as getDocument,\n  _n as getDocumentBody,\n  T as getDocumentElement,\n  to as getDocumentHead,\n  _t as getElementAnimationDelay,\n  te as getElementAnimationDuration,\n  So as getElementById,\n  g as getElementStyle,\n  ee as getElementTransitionDelay,\n  ne as getElementTransitionDuration,\n  No as getElementsByClassName,\n  de as getElementsByTagName,\n  Bn as getInstance,\n  eo as getNodeScroll,\n  no as getParentNode,\n  oo as getRectRelativeToOffsetParent,\n  ae as getUID,\n  so as getWindow,\n  Mn as hasAttribute,\n  Nn as hasAttributeNS,\n  In as hasClass,\n  gn as isApple,\n  ie as isArray,\n  co as isCanvas,\n  ue as isCustomElement,\n  R as isDocument,\n  ro as isElement,\n  ao as isElementInScrollRange,\n  io as isElementInViewport,\n  uo as isElementsArray,\n  vn as isFirefox,\n  lo as isFunction,\n  po as isHTMLCollection,\n  u as isHTMLElement,\n  fo as isHTMLImageElement,\n  mo as isJSON,\n  I as isMap,\n  vo as isMedia,\n  mn as isMobile,\n  i as isNode,\n  Eo as isNodeList,\n  se as isNumber,\n  v as isObject,\n  bo as isRTL,\n  ho as isSVGElement,\n  re as isScaledElement,\n  ce as isShadowRoot,\n  N as isString,\n  yo as isTableElement,\n  go as isWeakMap,\n  W as isWindow,\n  We as keyAlt,\n  Re as keyArrowDown,\n  qe as keyArrowLeft,\n  Ge as keyArrowRight,\n  Qe as keyArrowUp,\n  je as keyBackspace,\n  Je as keyCapsLock,\n  Ke as keyControl,\n  Xe as keyDelete,\n  Ye as keyEnter,\n  Ze as keyEscape,\n  $e as keyInsert,\n  _e as keyMeta,\n  tn as keyPause,\n  en as keyScrollLock,\n  nn as keyShift,\n  on as keySpace,\n  sn as keyTab,\n  Fe as keyboardEventKeys,\n  st as keydownEvent,\n  ct as keypressEvent,\n  rt as keyupEvent,\n  at as loadEvent,\n  xe as loadstartEvent,\n  ko as matches,\n  Be as mouseClickEvents,\n  He as mouseHoverEvents,\n  Ve as mouseSwipeEvents,\n  it as mouseclickEvent,\n  ut as mousedblclickEvent,\n  lt as mousedownEvent,\n  ft as mouseenterEvent,\n  pt as mousehoverEvent,\n  gt as mouseinEvent,\n  mt as mouseleaveEvent,\n  bt as mousemoveEvent,\n  vt as mouseoutEvent,\n  Et as mouseoverEvent,\n  dt as mouseupEvent,\n  ht as mousewheelEvent,\n  yt as moveEvent,\n  Te as nativeEvents,\n  Xt as noop,\n  Qn as normalizeOptions,\n  V as normalizeValue,\n  Jt as off,\n  un as offsetHeight,\n  ln as offsetWidth,\n  jt as on,\n  Kt as one,\n  wt as orientationchangeEvent,\n  Kn as passiveHandler,\n  At as pointercancelEvent,\n  St as pointerdownEvent,\n  Mt as pointerleaveEvent,\n  Nt as pointermoveEvent,\n  kt as pointerupEvent,\n  wo as querySelector,\n  Mo as querySelectorAll,\n  Tt as readystatechangeEvent,\n  Xn as reflow,\n  Dn as removeAttribute,\n  Cn as removeAttributeNS,\n  On as removeClass,\n  rn as removeEventListener,\n  Dt as resetEvent,\n  Ct as resizeEvent,\n  zt as scrollEvent,\n  dn as scrollHeight,\n  pn as scrollWidth,\n  Lt as selectEvent,\n  Ot as selectendEvent,\n  It as selectstartEvent,\n  kn as setAttribute,\n  Tn as setAttributeNS,\n  Yn as setElementStyle,\n  xt as submitEvent,\n  En as support3DTransform,\n  wn as supportAnimation,\n  bn as supportPassive,\n  yn as supportTouch,\n  hn as supportTransform,\n  An as supportTransition,\n  fn as tabindex,\n  oe as toLowerCase,\n  $n as toUpperCase,\n  Pe as touchEvents,\n  Ht as touchcancelEvent,\n  Pt as touchendEvent,\n  Bt as touchmoveEvent,\n  Vt as touchstartEvent,\n  Qt as transitionDelay,\n  Rt as transitionDuration,\n  C as transitionEndEvent,\n  F as transitionProperty,\n  Ut as unloadEvent,\n  S as userAgent,\n  A as userAgentData,\n  To as version\n};\n//# sourceMappingURL=shorty.mjs.map\n","const e = {}, f = (t) => {\n  const { type: c, currentTarget: i } = t;\n  [...e[c]].forEach(([n, s]) => {\n    i === n && [...s].forEach(([o, a]) => {\n      o.apply(n, [t]), typeof a == \"object\" && a.once && r(n, c, o, a);\n    });\n  });\n}, E = (t, c, i, n) => {\n  e[c] || (e[c] = /* @__PURE__ */ new Map());\n  const s = e[c];\n  s.has(t) || s.set(t, /* @__PURE__ */ new Map());\n  const o = s.get(t), { size: a } = o;\n  o.set(i, n), a || t.addEventListener(c, f, n);\n}, r = (t, c, i, n) => {\n  const s = e[c], o = s && s.get(t), a = o && o.get(i), d = a !== void 0 ? a : n;\n  o && o.has(i) && o.delete(i), s && (!o || !o.size) && s.delete(t), (!s || !s.size) && delete e[c], (!o || !o.size) && t.removeEventListener(c, f, d);\n}, g = E, M = r;\nexport {\n  E as addListener,\n  f as globalListener,\n  M as off,\n  g as on,\n  e as registry,\n  r as removeListener\n};\n//# sourceMappingURL=event-listener.mjs.map\n","/* Native JavaScript for Bootstrap 5 | Base Component\n----------------------------------------------------- */\nimport { querySelector, normalizeOptions, Data, ObjectKeys, isString } from '@thednp/shorty';\n\nimport type { BaseOptions } from '../interface/baseComponent';\nimport Version from '../version';\n\n/** Returns a new `BaseComponent` instance. */\nexport default class BaseComponent {\n  declare element: HTMLElement;\n  declare options?: BaseOptions;\n\n  /**\n   * @param target `HTMLElement` or selector string\n   * @param config component instance options\n   */\n  constructor(target: HTMLElement | string, config?: BaseOptions) {\n    const element = querySelector(target);\n\n    if (!element) {\n      if (isString(target)) {\n        throw Error(`${this.name} Error: \"${target}\" is not a valid selector.`);\n      } else {\n        throw Error(`${this.name} Error: your target is not an instance of HTMLElement.`);\n      }\n    }\n\n    const prevInstance = Data.get<typeof this>(element, this.name);\n    /* istanbul ignore else */\n    if (prevInstance) {\n      prevInstance.dispose();\n    }\n\n    this.element = element;\n    this.options =\n      this.defaults && ObjectKeys(this.defaults).length\n        ? normalizeOptions(element, this.defaults, config || {}, 'bs')\n        : {};\n\n    Data.set(element, this.name, this);\n  }\n\n  /* istanbul ignore next */\n  get version() {\n    return Version;\n  }\n\n  /* istanbul ignore next */\n  get name() {\n    return 'BaseComponent';\n  }\n\n  /* istanbul ignore next */\n  get defaults() {\n    return {};\n  }\n\n  /** Removes component from target element. */\n  dispose() {\n    Data.remove(this.element, this.name);\n    ObjectKeys(this).forEach(prop => {\n      delete this[prop];\n    });\n  }\n}\n","/** @type {string} */\nconst alertComponent = 'Alert';\nexport default alertComponent;\n","/* Native JavaScript for Bootstrap 5 | Alert\n-------------------------------------------- */\nimport {\n  emulateTransitionEnd,\n  mouseclickEvent,\n  getInstance,\n  querySelector,\n  hasClass,\n  removeClass,\n  dispatchEvent,\n  createCustomEvent,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport alertString from '../strings/alertString';\nimport alertComponent from '../strings/alertComponent';\nimport type { AlertEvent } from '../interface/alert';\n\nimport BaseComponent from './base-component';\n\n// ALERT PRIVATE GC\n// ================\nconst alertSelector = `.${alertString}`;\nconst alertDismissSelector = `[${dataBsDismiss}=\"${alertString}\"]`;\n\n/**\n * Static method which returns an existing `Alert` instance associated\n * to a target `Element`.\n *\n */\nconst getAlertInstance = (element: HTMLElement) => getInstance<Alert>(element, alertComponent);\n\n/**\n * An `Alert` initialization callback.\n */\nconst alertInitCallback = <T>(element: HTMLElement) => new Alert(element) as T;\n\n// ALERT CUSTOM EVENTS\n// ===================\nconst closeAlertEvent = createCustomEvent<AlertEvent>(`close.bs.${alertString}`);\nconst closedAlertEvent = createCustomEvent<AlertEvent>(`closed.bs.${alertString}`);\n\n// ALERT EVENT HANDLER\n// ===================\n/**\n * Alert `transitionend` callback.\n *\n * @param that target Alert instance\n */\nconst alertTransitionEnd = (that: Alert) => {\n  const { element } = that;\n  toggleAlertHandler(that);\n\n  dispatchEvent(element, closedAlertEvent);\n\n  that.dispose();\n  element.remove();\n};\n\n// ALERT PRIVATE METHOD\n// ====================\n/**\n * Toggle on / off the `click` event listener.\n *\n * @param that the target alert instance\n * @param add when `true`, event listener is added\n */\nconst toggleAlertHandler = (that: Alert, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { dismiss, close } = that;\n  /* istanbul ignore else */\n  if (dismiss) action(dismiss, mouseclickEvent, close);\n};\n\n// ALERT DEFINITION\n// ================\n/** Creates a new Alert instance. */\nexport default class Alert extends BaseComponent {\n  static selector = alertSelector;\n  static init = alertInitCallback;\n  static getInstance = getAlertInstance;\n  dismiss: HTMLElement | null;\n\n  constructor(target: HTMLElement | string) {\n    super(target);\n\n    // the dismiss button\n    this.dismiss = querySelector(alertDismissSelector, this.element);\n\n    // add event listener\n    toggleAlertHandler(this, true);\n  }\n\n  /** Returns component name string. */\n  get name() {\n    return alertComponent;\n  }\n\n  // ALERT PUBLIC METHODS\n  // ====================\n  /**\n   * Public method that hides the `.alert` element from the user,\n   * disposes the instance once animation is complete, then\n   * removes the element from the DOM.\n   */\n  close = () => {\n    const { element } = this;\n\n    /* istanbul ignore else */\n    if (element && hasClass(element, showClass)) {\n      dispatchEvent(element, closeAlertEvent);\n\n      if (!closeAlertEvent.defaultPrevented) {\n        removeClass(element, showClass);\n\n        if (hasClass(element, fadeClass)) {\n          emulateTransitionEnd(element, () => alertTransitionEnd(this));\n        } else alertTransitionEnd(this);\n      }\n    }\n  };\n\n  /** Remove the component from target element. */\n  dispose() {\n    toggleAlertHandler(this);\n    super.dispose();\n  }\n}\n","/**\n * Global namespace for most components `show` class.\n */\nconst showClass = 'show';\nexport default showClass;\n","/**\n * Global namespace for most components `fade` class.\n */\nconst fadeClass = 'fade';\nexport default fadeClass;\n","/**\n * Global namespace for most components active class.\n */\nconst activeClass = 'active';\nexport default activeClass;\n","/* Native JavaScript for Bootstrap 5 | Button\n---------------------------------------------*/\nimport {\n  getInstance,\n  removeClass,\n  hasClass,\n  addClass,\n  setAttribute,\n  mouseclickEvent,\n  ariaPressed,\n  getAttribute,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport activeClass from '../strings/activeClass';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport buttonString from '../strings/buttonString';\nimport buttonComponent from '../strings/buttonComponent';\n\nimport BaseComponent from './base-component';\n\n// BUTTON PRIVATE GC\n// =================\nconst buttonSelector = `[${dataBsToggle}=\"${buttonString}\"]`;\n\n/**\n * Static method which returns an existing `Button` instance associated\n * to a target `Element`.\n */\nconst getButtonInstance = (element: HTMLElement) => getInstance<Button>(element, buttonComponent);\n\n/** A `Button` initialization callback. */\nconst buttonInitCallback = (element: HTMLElement) => new Button(element);\n\n// BUTTON PRIVATE METHOD\n// =====================\n/**\n * Toggles on/off the `click` event listener.\n *\n * @param self the `Button` instance\n * @param add when `true`, event listener is added\n */\nconst toggleButtonHandler = (self: Button, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, self.toggle);\n};\n\n// BUTTON DEFINITION\n// =================\n/** Creates a new `Button` instance. */\nexport default class Button extends BaseComponent {\n  static selector = buttonSelector;\n  static init = buttonInitCallback;\n  static getInstance = getButtonInstance;\n\n  isActive = false;\n\n  /**\n   * @param target usually a `.btn` element\n   */\n  constructor(target: HTMLElement | string) {\n    super(target);\n\n    // initialization element\n    const { element } = this;\n\n    // set initial state\n    this.isActive = hasClass(element, activeClass);\n    setAttribute(element, ariaPressed, String(!!this.isActive));\n\n    // add event listener\n    toggleButtonHandler(this, true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return buttonComponent;\n  }\n\n  // BUTTON PUBLIC METHODS\n  // =====================\n  /**\n   * Toggles the state of the target button.\n   *\n   * @param e usually `click` Event object\n   */\n  toggle = (e: Event) => {\n    if (e) e.preventDefault();\n\n    const { element, isActive } = this;\n    if (!hasClass(element, 'disabled') && !getAttribute(element, 'disabled')) {\n      const action = isActive ? removeClass : addClass;\n      action(element, activeClass);\n      setAttribute(element, ariaPressed, isActive ? 'false' : 'true');\n      this.isActive = hasClass(element, activeClass);\n    }\n  };\n\n  /** Removes the `Button` component from the target element. */\n  dispose() {\n    toggleButtonHandler(this);\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst buttonComponent = 'Button';\nexport default buttonComponent;\n","/**\n * Global namespace for most components `target` option.\n */\nconst dataBsTarget = 'data-bs-target';\nexport default dataBsTarget;\n","import { getDocument, getAttribute, closest, querySelector } from '@thednp/shorty';\n\nimport dataBsTarget from '../strings/dataBsTarget';\nimport dataBsParent from '../strings/dataBsParent';\nimport dataBsContainer from '../strings/dataBsContainer';\n\n/**\n * Returns the `Element` that THIS one targets\n * via `data-bs-target`, `href`, `data-bs-parent` or `data-bs-container`.\n *\n * @param element the target element\n * @returns the query result\n */\nconst getTargetElement = (element: HTMLElement) => {\n  const targetAttr = [dataBsTarget, dataBsParent, dataBsContainer, 'href'];\n  const doc = getDocument(element);\n\n  return targetAttr\n    .map(att => {\n      const attValue = getAttribute(element, att);\n      if (attValue) {\n        return att === dataBsParent ? closest(element, attValue) : querySelector(attValue, doc);\n      }\n      return null;\n    })\n    .filter(x => x)[0];\n};\n\nexport default getTargetElement;\n","/**\n * Global namespace for most components `parent` option.\n */\nconst dataBsParent = 'data-bs-parent';\nexport default dataBsParent;\n","/**\n * Global namespace for most components `container` option.\n */\nconst dataBsContainer = 'data-bs-container';\nexport default dataBsContainer;\n","/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\nimport {\n  createCustomEvent,\n  getInstance,\n  dispatchEvent,\n  ObjectAssign,\n  emulateTransitionEnd,\n  passiveHandler,\n  reflow,\n  Timer,\n  getAttribute,\n  getElementsByClassName,\n  querySelectorAll,\n  querySelector,\n  closest,\n  isHTMLElement,\n  isRTL,\n  isElementInScrollRange,\n  getElementTransitionDuration,\n  getDocument,\n  pointerupEvent,\n  pointermoveEvent,\n  pointerdownEvent,\n  keyArrowRight,\n  keyArrowLeft,\n  keydownEvent,\n  mouseclickEvent,\n  mouseleaveEvent,\n  mouseenterEvent,\n  touchstartEvent,\n  dragstartEvent,\n  addClass,\n  hasClass,\n  removeClass,\n  matches,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport activeClass from '../strings/activeClass';\nimport dataBsTarget from '../strings/dataBsTarget';\nimport carouselString from '../strings/carouselString';\nimport carouselComponent from '../strings/carouselComponent';\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport type { CarouselEvent, CarouselOptions } from '../interface/carousel';\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults: CarouselOptions = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n */\nconst getCarouselInstance = (element: HTMLElement) => getInstance<Carousel>(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n */\nconst carouselInitCallback = (element: HTMLElement) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = createCustomEvent<CarouselEvent>(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = createCustomEvent<CarouselEvent>(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n *\n * @param self the `Carousel` instance\n */\nconst carouselTransitionEndHandler = (self: Carousel) => {\n  const { index, direction, element, slides, options } = self;\n\n  /* istanbul ignore else */\n  if (self.isAnimating) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // must check if a previous instance is disposed\n    if (self.cycle && !getDocument(element).hidden && options.interval && !self.isPaused) {\n      self.cycle();\n    }\n  }\n};\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselPauseHandler(this: HTMLElement) {\n  // const element = this;\n  const self = getCarouselInstance(this);\n  /* istanbul ignore else */\n  if (self && !self.isPaused && !Timer.get(this, pausedClass)) {\n    addClass(this, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n *\n */\nfunction carouselResumeHandler(this: HTMLElement) {\n  // const element = this;\n  const self = getCarouselInstance(this);\n  /* istanbul ignore else */\n  if (self && self.isPaused && !Timer.get(this, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @param e the `Event` object\n */\nfunction carouselIndicatorHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  // const indicator = this;\n  const element = (closest(this, carouselSelector) || getTargetElement(this)) as HTMLElement;\n  const self = getCarouselInstance(element);\n\n  if (self && !self.isAnimating) {\n    const newIndex = +(getAttribute(this, dataBsSlideTo) || /* istanbul ignore next */ 0);\n\n    if (\n      this &&\n      !hasClass(this, activeClass) && // event target is not active\n      !Number.isNaN(newIndex)\n    ) {\n      // AND has the specific attribute\n      self.to(newIndex); // do the slide\n    }\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @param e the `Event` object\n */\nfunction carouselControlsHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  const element = closest(this, carouselSelector) || (getTargetElement(this) as HTMLElement);\n  const self = getCarouselInstance(element);\n\n  if (self && !self.isAnimating) {\n    const orientation = getAttribute(this, dataBsSlide);\n\n    /* istanbul ignore else */\n    if (orientation === 'next') {\n      self.next();\n    } else if (orientation === 'prev') {\n      self.prev();\n    }\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param e the `Event` object\n */\nconst carouselKeyHandler = ({ code, target }: KeyboardEvent & { target: Node }) => {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)].filter(x => isElementInScrollRange(x));\n  const self = getCarouselInstance(element);\n\n  /* istanbul ignore next */\n  if (self && !self.isAnimating && !/textarea|input/i.test(target.nodeName)) {\n    const RTL = isRTL(element);\n    const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n    const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n    /* istanbul ignore else */\n    if (code === arrowKeyPrev) self.prev();\n    else if (code === arrowKeyNext) self.next();\n  }\n};\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Prevents the `touchstart` and `dragstart` events for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselDragHandler(this: HTMLElement, e: DragEvent | TouchEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  /* istanbul ignore next */\n  if (\n    self &&\n    self.isTouch &&\n    ((self.indicator && !self.indicator.contains(target as Node)) || !self.controls.includes(target as HTMLElement))\n  ) {\n    e.stopImmediatePropagation();\n    e.stopPropagation();\n    e.preventDefault();\n  }\n}\n\n// CAROUSEL POINTER HANDLERS\n// =========================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselPointerDownHandler(this: HTMLElement, e: PointerEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  if (self && !self.isAnimating && !self.isTouch) {\n    // filter pointer event on controls & indicators\n    const { controls, indicators } = self;\n    if (![...controls, ...indicators].every(el => el === target || el.contains(target as Node))) {\n      startX = e.pageX;\n\n      /* istanbul ignore else */\n      if (this.contains(target as Node)) {\n        self.isTouch = true;\n        toggleCarouselTouchHandlers(self, true);\n      }\n    }\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerMoveHandler = (e: PointerEvent) => {\n  currentX = e.pageX;\n};\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerUpHandler = (e: PointerEvent) => {\n  const { target } = e;\n  const doc = getDocument(target as Node);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map(c => getCarouselInstance(c) as Carousel)\n    .find(i => i.isTouch) as Carousel;\n\n  // impossible to satisfy\n  /* istanbul ignore else */\n  if (self) {\n    const { element, index } = self;\n    const RTL = isRTL(element);\n    endX = e.pageX;\n\n    self.isTouch = false;\n    toggleCarouselTouchHandlers(self);\n\n    if (\n      !doc.getSelection()?.toString().length &&\n      element.contains(target as HTMLElement) &&\n      Math.abs(startX - endX) > 120\n    ) {\n      // determine next index to slide to\n      /* istanbul ignore else */\n      if (currentX < startX) {\n        self.to(index + (RTL ? -1 : 1));\n      } else if (currentX > startX) {\n        self.to(index + (RTL ? 1 : -1));\n      }\n    }\n\n    // reset pointer position\n    startX = 0;\n    currentX = 0;\n    endX = 0;\n  }\n};\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param index the index of the new active indicator\n */\nconst activateCarouselIndicator = (self: Carousel, index: number) => {\n  const { indicators } = self;\n  [...indicators].forEach(x => removeClass(x, activeClass));\n\n  /* istanbul ignore else */\n  if (self.indicators[index]) addClass(indicators[index], activeClass);\n};\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselTouchHandlers = (self: Carousel, add?: boolean) => {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(getDocument(element), pointermoveEvent, carouselPointerMoveHandler as EventListener, passiveHandler);\n  action(getDocument(element), pointerupEvent, carouselPointerUpHandler as EventListener, passiveHandler);\n};\n\n/**\n * Toggles all event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselHandlers = (self: Carousel, add?: boolean) => {\n  const { element, options, slides, controls, indicators } = self;\n  const { touch, pause, interval, keyboard } = options;\n  const action = add ? addListener : removeListener;\n\n  if (pause && interval) {\n    action(element, mouseenterEvent, carouselPauseHandler);\n    action(element, mouseleaveEvent, carouselResumeHandler);\n  }\n\n  if (touch && slides.length > 2) {\n    action(element, pointerdownEvent, carouselPointerDownHandler as EventListener, passiveHandler);\n    action(element, touchstartEvent, carouselDragHandler as unknown as EventListener, { passive: false });\n    action(element, dragstartEvent, carouselDragHandler as unknown as EventListener, { passive: false });\n  }\n\n  /* istanbul ignore else */\n  if (controls.length) {\n    controls.forEach(arrow => {\n      /* istanbul ignore else */\n      if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler as EventListener);\n    });\n  }\n\n  /* istanbul ignore else */\n  if (indicators.length) {\n    indicators.forEach(indicator => {\n      action(indicator, mouseclickEvent, carouselIndicatorHandler as EventListener);\n    });\n  }\n\n  if (keyboard) action(getDocument(element), keydownEvent, carouselKeyHandler as EventListener);\n};\n\n/**\n * Returns the index of the current active item.\n *\n * @param self the `Carousel` instance\n * @returns the query result\n */\nconst getActiveIndex = (self: Carousel) => {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return isHTMLElement(activeItem) ? [...slides].indexOf(activeItem) : -1;\n};\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nexport default class Carousel extends BaseComponent {\n  static selector = carouselSelector;\n  static init = carouselInitCallback;\n  static getInstance = getCarouselInstance;\n  declare options: CarouselOptions;\n  declare direction: 'right' | 'left';\n  declare index: number;\n  declare isTouch: boolean;\n  declare slides: HTMLCollectionOf<HTMLElement>;\n  declare controls: HTMLElement[];\n  declare indicator: HTMLElement | null;\n  declare indicators: HTMLElement[];\n\n  /**\n   * @param target mostly a `.carousel` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CarouselOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element } = this;\n\n    // additional properties\n    this.direction = isRTL(element) ? 'right' : 'left';\n    this.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    this.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = this;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length >= 2) {\n      const activeIndex = getActiveIndex(this);\n      // recover item from disposed instance\n      const transitionItem = [...slides].find(s => matches(s, `.${carouselItem}-next,.${carouselItem}-next`));\n      this.index = activeIndex;\n\n      // external controls must be within same document context\n      const doc = getDocument(element);\n\n      this.controls = [\n        ...querySelectorAll(`[${dataBsSlide}]`, element),\n        ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      this.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n      // a LIVE collection is prefferable\n      this.indicators = [\n        ...(this.indicator ? querySelectorAll(`[${dataBsSlideTo}]`, this.indicator) : []),\n        ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      // set JavaScript and DATA API options\n      const { options } = this;\n\n      // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n      this.options.interval = options.interval === true ? carouselDefaults.interval : options.interval;\n\n      // set first slide active if none\n      /* istanbul ignore next - impossible to test with cypress */\n      if (transitionItem) {\n        this.index = [...slides].indexOf(transitionItem);\n      } else if (activeIndex < 0) {\n        this.index = 0;\n        addClass(slides[0], activeClass);\n        if (this.indicators.length) activateCarouselIndicator(this, 0);\n      }\n\n      /* istanbul ignore else */\n      if (this.indicators.length) activateCarouselIndicator(this, this.index);\n\n      // attach event handlers\n      toggleCarouselHandlers(this, true);\n\n      // start to cycle if interval is set\n      if (options.interval) this.cycle();\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return carouselComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return carouselDefaults;\n  }\n\n  /**\n   * Check if instance is paused.\n   */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const { element, options, isPaused, index } = this;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(\n      element,\n      () => {\n        // it's very important to check self.element\n        // where instance might have been disposed\n        /* istanbul ignore else */\n        if (this.element && !this.isPaused && !this.isTouch && isElementInScrollRange(element)) {\n          this.to(index + 1);\n        }\n      },\n      options.interval as number,\n      carouselString,\n    );\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const { element, options } = this;\n    /* istanbul ignore else */\n    if (!this.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(\n        element,\n        () => {\n          /* ESLint is now happy */\n        },\n        1,\n        pausedClass,\n      );\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    /* istanbul ignore else */\n    if (!this.isAnimating) {\n      this.to(this.index + 1);\n    }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    /* istanbul ignore else */\n    if (!this.isAnimating) {\n      this.to(this.index - 1);\n    }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   *\n   * @param idx the index of the item to jump to\n   */\n  to(idx: number) {\n    const { element, slides, options } = this;\n    const activeItem = getActiveIndex(this);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (!this.isAnimating && activeItem !== next && !Timer.get(element, dataBsSlide)) {\n      // determine transition direction\n      /* istanbul ignore else */\n      if (activeItem < next || (activeItem === 0 && next === slides.length - 1)) {\n        this.direction = RTL ? 'right' : 'left'; // next\n      } else if (activeItem > next || (activeItem === slides.length - 1 && next === 0)) {\n        this.direction = RTL ? 'left' : 'right'; // prev\n      }\n      const { direction } = this;\n\n      // find the right next index\n      if (next < 0) {\n        next = slides.length - 1;\n      } else if (next >= slides.length) {\n        next = 0;\n      }\n\n      // orientation, class name, eventProperties\n      const orientation = direction === 'left' ? 'next' : 'prev';\n      const directionClass = direction === 'left' ? 'start' : 'end';\n\n      const eventProperties = {\n        relatedTarget: slides[next],\n        from: activeItem,\n        to: next,\n        direction,\n      };\n\n      // update event properties\n      ObjectAssign(carouselSlideEvent, eventProperties);\n      ObjectAssign(carouselSlidEvent, eventProperties);\n\n      // discontinue when prevented\n      dispatchEvent(element, carouselSlideEvent);\n      if (!carouselSlideEvent.defaultPrevented) {\n        // update index\n        this.index = next;\n        activateCarouselIndicator(this, next);\n\n        if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n          Timer.set(\n            element,\n            () => {\n              addClass(slides[next], `${carouselItem}-${orientation}`);\n              reflow(slides[next]);\n              addClass(slides[next], `${carouselItem}-${directionClass}`);\n              addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n              // the instance might get diposed mid-animation\n              emulateTransitionEnd(\n                slides[next],\n                () => this.slides && this.slides.length && carouselTransitionEndHandler(this),\n              );\n            },\n            0,\n            dataBsSlide,\n          );\n        } else {\n          addClass(slides[next], activeClass);\n          removeClass(slides[activeItem], activeClass);\n\n          Timer.set(\n            element,\n            () => {\n              Timer.clear(element, dataBsSlide);\n              // check for element, might have been disposed\n              /* istanbul ignore else */\n              if (element && options.interval && !this.isPaused) {\n                this.cycle();\n              }\n\n              dispatchEvent(element, carouselSlidEvent);\n            },\n            0,\n            dataBsSlide,\n          );\n        }\n      }\n    }\n  }\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const { isAnimating } = this;\n\n    const clone = {\n      ...this,\n      isAnimating,\n    };\n    toggleCarouselHandlers(clone);\n    super.dispose();\n\n    // istanbul ignore next - impossible to test with cypress\n    if (clone.isAnimating) {\n      emulateTransitionEnd(clone.slides[clone.index], () => {\n        carouselTransitionEndHandler(clone);\n      });\n    }\n  }\n}\n","/** @type {string} */\nconst carouselComponent = 'Carousel';\nexport default carouselComponent;\n","/** @type {string} */\nconst carouselString = 'carousel';\nexport default carouselString;\n","/**\n * Global namespace for most components `collapsing` class.\n * As used by `Collapse` / `Tab`.\n */\nconst collapsingClass = 'collapsing';\nexport default collapsingClass;\n","/* Native JavaScript for Bootstrap 5 | Collapse\n----------------------------------------------- */\nimport {\n  getInstance,\n  setAttribute,\n  getDocument,\n  closest,\n  querySelector,\n  querySelectorAll,\n  addClass,\n  hasClass,\n  removeClass,\n  mouseclickEvent,\n  ariaExpanded,\n  emulateTransitionEnd,\n  reflow,\n  dispatchEvent,\n  setElementStyle,\n  Timer,\n  createCustomEvent,\n  noop,\n  isHTMLElement,\n  isString,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsToggle from '../strings/dataBsToggle';\nimport collapsingClass from '../strings/collapsingClass';\nimport showClass from '../strings/showClass';\nimport collapseString from '../strings/collapseString';\nimport collapseComponent from '../strings/collapseComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport type { CollapseEvent, CollapseOptions } from '../interface/collapse';\n\n// COLLAPSE GC\n// ===========\nconst collapseSelector = `.${collapseString}`;\nconst collapseToggleSelector = `[${dataBsToggle}=\"${collapseString}\"]`;\nconst collapseDefaults = { parent: null };\n\n/**\n * Static method which returns an existing `Collapse` instance associated\n * to a target `Element`.\n */\nconst getCollapseInstance = (element: HTMLElement) => getInstance<Collapse>(element, collapseComponent);\n\n/**\n * A `Collapse` initialization callback.\n */\nconst collapseInitCallback = (element: HTMLElement) => new Collapse(element);\n\n// COLLAPSE CUSTOM EVENTS\n// ======================\nconst showCollapseEvent = createCustomEvent<CollapseEvent>(`show.bs.${collapseString}`);\nconst shownCollapseEvent = createCustomEvent<CollapseEvent>(`shown.bs.${collapseString}`);\nconst hideCollapseEvent = createCustomEvent<CollapseEvent>(`hide.bs.${collapseString}`);\nconst hiddenCollapseEvent = createCustomEvent<CollapseEvent>(`hidden.bs.${collapseString}`);\n\n// COLLAPSE PRIVATE METHODS\n// ========================\n/**\n * Expand the designated `Element`.\n *\n * @param self the `Collapse` instance\n */\nconst expandCollapse = (self: Collapse) => {\n  const { element, parent, triggers } = self;\n\n  dispatchEvent(element, showCollapseEvent);\n  if (!showCollapseEvent.defaultPrevented) {\n    Timer.set(element, noop, 17);\n    if (parent) Timer.set(parent, noop, 17);\n\n    addClass(element, collapsingClass);\n    removeClass(element, collapseString);\n\n    setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n    emulateTransitionEnd(element, () => {\n      Timer.clear(element);\n      if (parent) Timer.clear(parent);\n\n      triggers.forEach(btn => setAttribute(btn, ariaExpanded, 'true'));\n\n      removeClass(element, collapsingClass);\n      addClass(element, collapseString);\n      addClass(element, showClass);\n\n      setElementStyle(element, { height: '' });\n\n      dispatchEvent(element, shownCollapseEvent);\n    });\n  }\n};\n\n/**\n * Collapse the designated `Element`.\n *\n * @param self the `Collapse` instance\n */\nconst collapseContent = (self: Collapse) => {\n  const { element, parent, triggers } = self;\n\n  dispatchEvent(element, hideCollapseEvent);\n\n  if (!hideCollapseEvent.defaultPrevented) {\n    Timer.set(element, noop, 17);\n    if (parent) Timer.set(parent, noop, 17);\n\n    setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n    removeClass(element, collapseString);\n    removeClass(element, showClass);\n    addClass(element, collapsingClass);\n\n    reflow(element);\n    setElementStyle(element, { height: '0px' });\n\n    emulateTransitionEnd(element, () => {\n      Timer.clear(element);\n      /* istanbul ignore else */\n      if (parent) Timer.clear(parent);\n\n      triggers.forEach(btn => setAttribute(btn, ariaExpanded, 'false'));\n\n      removeClass(element, collapsingClass);\n      addClass(element, collapseString);\n\n      setElementStyle(element, { height: '' });\n\n      dispatchEvent(element, hiddenCollapseEvent);\n    });\n  }\n};\n\n/**\n * Toggles on/off the event listener(s) of the `Collapse` instance.\n *\n * @param self the `Collapse` instance\n * @param add when `true`, the event listener is added\n */\nconst toggleCollapseHandler = (self: Collapse, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach(btn => action(btn, mouseclickEvent, collapseClickHandler as EventListener));\n  }\n};\n\n// COLLAPSE EVENT HANDLER\n// ======================\n/**\n * Handles the `click` event for the `Collapse` instance.\n *\n * @param e the `Event` object\n */\nconst collapseClickHandler = (e: MouseEvent) => {\n  const { target } = e; // our target is `HTMLElement`\n  const trigger = target && closest(target as HTMLElement, collapseToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getCollapseInstance(element);\n  /* istanbul ignore else */\n  if (self) self.toggle();\n\n  // event target is anchor link #398\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n};\n\n// COLLAPSE DEFINITION\n// ===================\n\n/** Returns a new `Colapse` instance. */\nexport default class Collapse extends BaseComponent {\n  static selector = collapseSelector;\n  static init = collapseInitCallback;\n  static getInstance = getCollapseInstance;\n  declare options: CollapseOptions;\n  declare parent: HTMLElement | null;\n  declare triggers: HTMLElement[];\n\n  /**\n   * @param target and `Element` that matches the selector\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CollapseOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element, options } = this;\n    const doc = getDocument(element);\n\n    // set triggering elements\n    this.triggers = [...querySelectorAll(collapseToggleSelector, doc)].filter(btn => getTargetElement(btn) === element);\n\n    // set parent accordion\n    this.parent = isHTMLElement(options.parent)\n      ? options.parent\n      : isString(options.parent)\n      ? getTargetElement(element) || querySelector(options.parent as string, doc)\n      : null;\n\n    // add event listeners\n    toggleCollapseHandler(this, true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return collapseComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return collapseDefaults;\n  }\n\n  // COLLAPSE PUBLIC METHODS\n  // =======================\n  /** Toggles the visibility of the collapse. */\n  toggle() {\n    if (!hasClass(this.element, showClass)) this.show();\n    else this.hide();\n  }\n\n  /** Hides the collapse. */\n  hide() {\n    const { triggers, element } = this;\n    if (!Timer.get(element)) {\n      collapseContent(this);\n      /* istanbul ignore else */\n      if (triggers.length) {\n        triggers.forEach(btn => addClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Shows the collapse. */\n  show() {\n    const { element, parent, triggers } = this;\n    let activeCollapse;\n    let activeCollapseInstance;\n\n    if (parent) {\n      activeCollapse = [...querySelectorAll(`.${collapseString}.${showClass}`, parent)].find(i =>\n        getCollapseInstance(i),\n      );\n      activeCollapseInstance = activeCollapse && getCollapseInstance(activeCollapse);\n    }\n\n    if ((!parent || !Timer.get(parent)) && !Timer.get(element)) {\n      if (activeCollapseInstance && activeCollapse !== element) {\n        collapseContent(activeCollapseInstance);\n        activeCollapseInstance.triggers.forEach(btn => {\n          addClass(btn, `${collapseString}d`);\n        });\n      }\n\n      expandCollapse(this);\n      /* istanbul ignore else */\n      if (triggers.length) {\n        triggers.forEach(btn => removeClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Remove the `Collapse` component from the target `Element`. */\n  dispose() {\n    toggleCollapseHandler(this);\n\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst collapseComponent = 'Collapse';\nexport default collapseComponent;\n","/** @type {string} */\nconst collapseString = 'collapse';\nexport default collapseString;\n","/**\n * Global namespace for `Dropdown` types / classes.\n */\nconst dropdownMenuClasses = ['dropdown', 'dropup', 'dropstart', 'dropend'];\nexport default dropdownMenuClasses;\n","import { hasAttribute, closest, getAttribute } from '@thednp/shorty';\n\n/**\n * Checks if an *event.target* or its parent has an `href=\"#\"` value.\n * We need to prevent jumping around onclick, don't we?\n *\n * @param element the target element\n * @returns the query result\n */\nconst isEmptyAnchor = (element: HTMLElement) => {\n  // `EventTarget` must be `HTMLElement`\n  const parentAnchor = closest(element, 'A');\n  return (\n    (element.tagName === 'A' &&\n      // anchor href starts with #\n      hasAttribute(element, 'href') &&\n      (getAttribute(element, 'href') as string).slice(-1) === '#') ||\n    // OR a child of an anchor with href starts with #\n    (parentAnchor &&\n      hasAttribute(parentAnchor, 'href') &&\n      (getAttribute(parentAnchor, 'href') as string).slice(-1) === '#')\n  );\n};\nexport default isEmptyAnchor;\n","/* Native JavaScript for Bootstrap 5 | Dropdown\n----------------------------------------------- */\nimport {\n  ariaExpanded,\n  focusEvent,\n  keydownEvent,\n  setAttribute,\n  keyEscape,\n  keyArrowDown,\n  keyArrowUp,\n  mouseclickEvent,\n  resizeEvent,\n  scrollEvent,\n  keyupEvent,\n  dispatchEvent,\n  setElementStyle,\n  getInstance,\n  ObjectAssign,\n  passiveHandler,\n  getElementsByClassName,\n  closest,\n  getAttribute,\n  getDocument,\n  getBoundingClientRect,\n  getDocumentElement,\n  getElementStyle,\n  isRTL,\n  removeClass,\n  hasClass,\n  addClass,\n  createCustomEvent,\n  focus,\n  getWindow,\n  CSS4Declaration,\n  isHTMLElement,\n  mousedownEvent,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport showClass from '../strings/showClass';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport dropdownClasses from '../strings/dropdownClasses';\nimport dropdownComponent from '../strings/dropdownComponent';\nimport dropdownMenuClass from '../strings/dropdownMenuClass';\n\nimport isEmptyAnchor from '../util/isEmptyAnchor';\nimport BaseComponent from './base-component';\nimport type { DropdownEvent, DropdownOptions } from '../interface/dropdown';\n\n// DROPDOWN PRIVATE GC\n// ===================\nconst [dropdownString, dropupString, dropstartString, dropendString] = dropdownClasses;\nconst dropdownSelector = `[${dataBsToggle}=\"${dropdownString}\"]`;\n\n/**\n * Static method which returns an existing `Dropdown` instance associated\n * to a target `Element`.\n */\nconst getDropdownInstance = (element: HTMLElement) => getInstance<Dropdown>(element, dropdownComponent);\n\n/**\n * A `Dropdown` initialization callback.\n */\nconst dropdownInitCallback = (element: HTMLElement) => new Dropdown(element);\n\n// DROPDOWN PRIVATE GC\n// ===================\n// const dropdownMenuStartClass = `${dropdownMenuClass}-start`;\nconst dropdownMenuEndClass = `${dropdownMenuClass}-end`;\nconst verticalClass = [dropdownString, dropupString];\nconst horizontalClass = [dropstartString, dropendString];\nconst menuFocusTags = ['A', 'BUTTON'];\n\nconst dropdownDefaults = {\n  offset: 5, // [number] 5(px)\n  display: 'dynamic', // [dynamic|static]\n};\n\n// DROPDOWN CUSTOM EVENTS\n// ======================\nconst showDropdownEvent = createCustomEvent<DropdownEvent>(`show.bs.${dropdownString}`);\nconst shownDropdownEvent = createCustomEvent<DropdownEvent>(`shown.bs.${dropdownString}`);\nconst hideDropdownEvent = createCustomEvent<DropdownEvent>(`hide.bs.${dropdownString}`);\nconst hiddenDropdownEvent = createCustomEvent<DropdownEvent>(`hidden.bs.${dropdownString}`);\nconst updatedDropdownEvent = createCustomEvent<DropdownEvent>(`updated.bs.${dropdownString}`);\n\n// DROPDOWN PRIVATE METHODS\n// ========================\n/**\n * Apply specific style or class names to a `.dropdown-menu` to automatically\n * accomodate the layout and the page scroll.\n *\n * @param self the `Dropdown` instance\n */\nconst styleDropdown = (self: Dropdown) => {\n  const { element, menu, parentElement, options } = self;\n  const { offset } = options;\n\n  // don't apply any style on mobile view\n  /* istanbul ignore else: this test requires a navbar */\n  if (getElementStyle(menu, 'position') !== 'static') {\n    const RTL = isRTL(element);\n    // const menuStart = hasClass(menu, dropdownMenuStartClass);\n    const menuEnd = hasClass(menu, dropdownMenuEndClass);\n\n    // reset menu offset and position\n    const resetProps = ['margin', 'top', 'bottom', 'left', 'right'];\n    resetProps.forEach(p => {\n      // menu.style[p] = '';\n      const style: { [key: string]: string } = {};\n      style[p] = '';\n      setElementStyle(menu, style);\n    });\n\n    // set initial position class\n    // take into account .btn-group parent as .dropdown\n    // this requires navbar/btn-group/input-group\n    let positionClass =\n      dropdownClasses.find(c => hasClass(parentElement, c)) ||\n      /* istanbul ignore next: fallback position */ dropdownString;\n\n    const dropdownMargin: { [key: string]: number[] } = {\n      dropdown: [offset, 0, 0],\n      dropup: [0, 0, offset],\n      dropstart: RTL ? [-1, 0, 0, offset] : [-1, offset, 0],\n      dropend: RTL ? [-1, offset, 0] : [-1, 0, 0, offset],\n    };\n\n    const dropdownPosition: { [key: string]: Partial<CSS4Declaration> } = {\n      dropdown: { top: '100%' },\n      dropup: { top: 'auto', bottom: '100%' },\n      dropstart: RTL ? { left: '100%', right: 'auto' } : { left: 'auto', right: '100%' },\n      dropend: RTL ? { left: 'auto', right: '100%' } : { left: '100%', right: 'auto' },\n      menuStart: RTL ? { right: '0', left: 'auto' } : { right: 'auto', left: '0' },\n      menuEnd: RTL ? { right: 'auto', left: '0' } : { right: '0', left: 'auto' },\n    };\n\n    const { offsetWidth: menuWidth, offsetHeight: menuHeight } = menu;\n\n    const { clientWidth, clientHeight } = getDocumentElement(element);\n    const {\n      left: targetLeft,\n      top: targetTop,\n      width: targetWidth,\n      height: targetHeight,\n    } = getBoundingClientRect(element);\n\n    // dropstart | dropend\n    const leftFullExceed = targetLeft - menuWidth - offset < 0;\n    // dropend\n    const rightFullExceed = targetLeft + menuWidth + targetWidth + offset >= clientWidth;\n    // dropstart | dropend\n    const bottomExceed = targetTop + menuHeight + offset >= clientHeight;\n    // dropdown\n    const bottomFullExceed = targetTop + menuHeight + targetHeight + offset >= clientHeight;\n    // dropup\n    const topExceed = targetTop - menuHeight - offset < 0;\n    // dropdown / dropup\n    const leftExceed = ((!RTL && menuEnd) || (RTL && !menuEnd)) && targetLeft + targetWidth - menuWidth < 0;\n    const rightExceed = ((RTL && menuEnd) || (!RTL && !menuEnd)) && targetLeft + menuWidth >= clientWidth;\n\n    // recompute position\n    // handle RTL as well\n    if (horizontalClass.includes(positionClass) && leftFullExceed && rightFullExceed) {\n      positionClass = dropdownString;\n    }\n    if (positionClass === dropstartString && (!RTL ? leftFullExceed : rightFullExceed)) {\n      positionClass = dropendString;\n    }\n    if (positionClass === dropendString && (RTL ? leftFullExceed : rightFullExceed)) {\n      positionClass = dropstartString;\n    }\n    if (positionClass === dropupString && topExceed && !bottomFullExceed) {\n      positionClass = dropdownString;\n    }\n    if (positionClass === dropdownString && bottomFullExceed && !topExceed) {\n      positionClass = dropupString;\n    }\n\n    // override position for horizontal classes\n    if (horizontalClass.includes(positionClass) && bottomExceed) {\n      ObjectAssign(dropdownPosition[positionClass], {\n        top: 'auto',\n        bottom: 0,\n      });\n    }\n\n    // override position for vertical classes\n    if (verticalClass.includes(positionClass) && (leftExceed || rightExceed)) {\n      // don't realign when menu is wider than window\n      // in both RTL and non-RTL readability is KING\n      let posAjust: { left: 'auto' | number; right: 'auto' | number } | undefined = { left: 'auto', right: 'auto' };\n      if (!leftExceed && rightExceed && !RTL) posAjust = { left: 'auto', right: 0 };\n      if (leftExceed && !rightExceed && RTL) posAjust = { left: 0, right: 'auto' };\n      if (posAjust) ObjectAssign(dropdownPosition[positionClass], posAjust);\n    }\n\n    const margins: number[] = dropdownMargin[positionClass];\n    setElementStyle(menu, {\n      ...dropdownPosition[positionClass],\n      margin: `${margins.map(x => (x ? `${x}px` : x)).join(' ')}`,\n    });\n\n    // override dropdown-menu-start | dropdown-menu-end\n    if (verticalClass.includes(positionClass) && menuEnd) {\n      /* istanbul ignore else */\n      if (menuEnd) {\n        const endAdjust =\n          (!RTL && leftExceed) || (RTL && rightExceed) ? 'menuStart' : /* istanbul ignore next */ 'menuEnd';\n        setElementStyle(menu, dropdownPosition[endAdjust]);\n      }\n    }\n    // trigger updated event\n    dispatchEvent(parentElement, updatedDropdownEvent);\n  }\n};\n\n/**\n * Returns an `Array` of focusable items in the given dropdown-menu.\n *\n * @param menu the target menu\n * @returns all children of the dropdown menu\n */\nconst getMenuItems = (menu: HTMLElement) => {\n  return [...menu.children]\n    .map(c => {\n      if (c && menuFocusTags.includes(c.tagName)) return c;\n      const { firstElementChild } = c;\n      if (firstElementChild && menuFocusTags.includes(firstElementChild.tagName)) {\n        return firstElementChild;\n      }\n      return null;\n    })\n    .filter(c => c);\n};\n\n/**\n * Toggles on/off the listeners for the events that close the dropdown\n * as well as event that request a new position for the dropdown.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nconst toggleDropdownDismiss = (self: Dropdown) => {\n  const { element, options } = self;\n  const action = self.open ? addListener : removeListener;\n  const doc = getDocument(element);\n\n  action(doc, mouseclickEvent, dropdownDismissHandler as EventListener);\n  action(doc, focusEvent, dropdownDismissHandler as EventListener);\n  action(doc, keydownEvent, dropdownPreventScroll as EventListener);\n  action(doc, keyupEvent, dropdownKeyHandler as EventListener);\n\n  /* istanbul ignore else */\n  if (options.display === 'dynamic') {\n    [scrollEvent, resizeEvent].forEach(ev => {\n      action(getWindow(element), ev, dropdownLayoutHandler, passiveHandler);\n    });\n  }\n};\n\n/**\n * Toggles on/off the `click` event listener of the `Dropdown`.\n *\n * @param self the `Dropdown` instance\n * @param add when `true`, it will add the event listener\n */\nconst toggleDropdownHandler = (self: Dropdown, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, dropdownClickHandler as EventListener);\n};\n\n/**\n * Returns the currently open `.dropdown` element.\n *\n * @param element target\n * @returns the query result\n */\nconst getCurrentOpenDropdown = (element: HTMLElement): HTMLElement | undefined => {\n  const currentParent = [...dropdownClasses, 'btn-group', 'input-group']\n    .map(c => getElementsByClassName(`${c} ${showClass}`, getDocument(element)))\n    .find(x => x.length);\n\n  if (currentParent && currentParent.length) {\n    return [...(currentParent[0].children as HTMLCollectionOf<HTMLElement>)].find(x =>\n      dropdownClasses.some(c => c === getAttribute(x, dataBsToggle)),\n    );\n  }\n  return undefined;\n};\n\n// DROPDOWN EVENT HANDLERS\n// =======================\n/**\n * Handles the `click` event for the `Dropdown` instance.\n *\n * @param e event object\n */\nconst dropdownDismissHandler = (e: MouseEvent) => {\n  const { target, type } = e;\n\n  /* istanbul ignore else */\n  if (target && isHTMLElement(target)) {\n    // some weird FF bug #409\n    const element = getCurrentOpenDropdown(target);\n    const self = element && getDropdownInstance(element);\n\n    /* istanbul ignore else */\n    if (self) {\n      const { parentElement, menu } = self;\n\n      const isForm =\n        parentElement &&\n        parentElement.contains(target) &&\n        (target.tagName === 'form' || closest(target, 'form') !== null);\n\n      if ([mouseclickEvent, mousedownEvent].includes(type) && isEmptyAnchor(target)) {\n        e.preventDefault();\n      }\n\n      /* istanbul ignore else */\n      if (!isForm && type !== focusEvent && target !== element && target !== menu) {\n        self.hide();\n      }\n    }\n  }\n};\n\n/**\n * Handles `click` event listener for `Dropdown`.\n *\n * @param e event object\n */\nconst dropdownClickHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = target && closest(target as HTMLElement, dropdownSelector);\n  const self = element && getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    e.stopPropagation();\n    self.toggle();\n    /* istanbul ignore else */\n    if (element && isEmptyAnchor(element)) e.preventDefault();\n  }\n};\n\n/**\n * Prevents scroll when dropdown-menu is visible.\n *\n * @param e event object\n */\nconst dropdownPreventScroll = (e: KeyboardEvent) => {\n  /* istanbul ignore else */\n  if ([keyArrowDown, keyArrowUp].includes(e.code)) e.preventDefault();\n};\n\n/**\n * Handles keyboard `keydown` events for `Dropdown`.\n *\n * @param e keyboard key\n */\nfunction dropdownKeyHandler(this: HTMLElement, e: KeyboardEvent) {\n  const { code } = e;\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n  const { activeElement } = (element && getDocument(element)) as Document;\n\n  /* istanbul ignore else */\n  if (self && activeElement) {\n    const { menu, open } = self;\n    const menuItems = getMenuItems(menu);\n\n    // arrow up & down\n    if (menuItems && menuItems.length && [keyArrowDown, keyArrowUp].includes(code)) {\n      let idx = menuItems.indexOf(activeElement);\n      /* istanbul ignore else */\n      if (activeElement === element) {\n        idx = 0;\n      } else if (code === keyArrowUp) {\n        idx = idx > 1 ? idx - 1 : 0;\n      } else if (code === keyArrowDown) {\n        idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n      }\n      /* istanbul ignore else */\n      if (menuItems[idx]) focus(menuItems[idx] as HTMLElement);\n    }\n\n    if (keyEscape === code && open) {\n      self.toggle();\n      focus(element);\n    }\n  }\n}\n\n/** Handles dropdown layout changes during resize / scroll. */\nfunction dropdownLayoutHandler(this: HTMLElement) {\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self && self.open) styleDropdown(self);\n}\n\n// DROPDOWN DEFINITION\n// ===================\n/** Returns a new Dropdown instance. */\nexport default class Dropdown extends BaseComponent {\n  static selector = dropdownSelector;\n  static init = dropdownInitCallback;\n  static getInstance = getDropdownInstance;\n  declare options: DropdownOptions;\n  declare open: boolean;\n  declare parentElement: HTMLElement;\n  declare menu: HTMLElement;\n\n  /**\n   * @param target Element or string selector\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<DropdownOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { parentElement } = this.element;\n    const [menu] = getElementsByClassName(dropdownMenuClass, parentElement as ParentNode);\n\n    // invalidate when dropdown-menu is missing\n    if (menu) {\n      // set targets\n      this.parentElement = parentElement as HTMLElement;\n      this.menu = menu;\n\n      // add event listener\n      toggleDropdownHandler(this, true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return dropdownComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return dropdownDefaults;\n  }\n\n  // DROPDOWN PUBLIC METHODS\n  // =======================\n  /** Shows/hides the dropdown menu to the user. */\n  toggle() {\n    if (this.open) this.hide();\n    else this.show();\n  }\n\n  /** Shows the dropdown menu to the user. */\n  show() {\n    const { element, open, menu, parentElement } = this;\n\n    /* istanbul ignore else */\n    if (!open) {\n      const currentElement = getCurrentOpenDropdown(element);\n      const currentInstance = currentElement && getDropdownInstance(currentElement);\n      if (currentInstance) currentInstance.hide();\n\n      // dispatch event\n      [showDropdownEvent, shownDropdownEvent, updatedDropdownEvent].forEach(e => {\n        e.relatedTarget = element;\n      });\n\n      dispatchEvent(parentElement, showDropdownEvent);\n      if (!showDropdownEvent.defaultPrevented) {\n        addClass(menu, showClass);\n        addClass(parentElement, showClass);\n        setAttribute(element, ariaExpanded, 'true');\n\n        // change menu position\n        styleDropdown(this);\n\n        this.open = !open;\n\n        focus(element); // focus the element\n        toggleDropdownDismiss(this);\n        dispatchEvent(parentElement, shownDropdownEvent);\n      }\n    }\n  }\n\n  /** Hides the dropdown menu from the user. */\n  hide() {\n    const { element, open, menu, parentElement } = this;\n\n    /* istanbul ignore else */\n    if (open) {\n      [hideDropdownEvent, hiddenDropdownEvent].forEach(e => {\n        e.relatedTarget = element;\n      });\n\n      dispatchEvent(parentElement, hideDropdownEvent);\n      if (!hideDropdownEvent.defaultPrevented) {\n        removeClass(menu, showClass);\n        removeClass(parentElement, showClass);\n        setAttribute(element, ariaExpanded, 'false');\n\n        this.open = !open;\n        // only re-attach handler if the instance is not disposed\n        toggleDropdownDismiss(this);\n        dispatchEvent(parentElement, hiddenDropdownEvent);\n      }\n    }\n  }\n\n  /** Removes the `Dropdown` component from the target element. */\n  dispose() {\n    if (this.open) this.hide();\n\n    toggleDropdownHandler(this);\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst dropdownComponent = 'Dropdown';\nexport default dropdownComponent;\n","/**\n * Global namespace for most components `toggle` option.\n */\nconst dataBsToggle = 'data-bs-toggle';\nexport default dataBsToggle;\n","/**\n * Global namespace for `.dropdown-menu`.\n */\nconst dropdownMenuClass = 'dropdown-menu';\nexport default dropdownMenuClass;\n","/** @type {string} */\nconst modalString = 'modal';\nexport default modalString;\n","/**\n * Global namespace for components `sticky-top` class.\n */\nconst stickyTopClass = 'sticky-top';\nexport default stickyTopClass;\n","/**\n * Global namespace for components `position-sticky` class.\n */\nconst positionStickyClass = 'position-sticky';\nexport default positionStickyClass;\n","import {\n  getWindow,\n  getDocumentElement,\n  getElementStyle,\n  getDocumentBody,\n  hasClass,\n  setElementStyle,\n  getElementsByClassName,\n} from '@thednp/shorty';\n\nimport fixedTopClass from '../strings/fixedTopClass';\nimport fixedBottomClass from '../strings/fixedBottomClass';\nimport stickyTopClass from '../strings/stickyTopClass';\nimport positionStickyClass from '../strings/positionStickyClass';\n\nconst getFixedItems = (parent?: ParentNode) => [\n  ...getElementsByClassName(fixedTopClass, parent),\n  ...getElementsByClassName(fixedBottomClass, parent),\n  ...getElementsByClassName(stickyTopClass, parent),\n  ...getElementsByClassName(positionStickyClass, parent),\n  ...getElementsByClassName('is-fixed', parent),\n];\n\n/**\n * Removes *padding* and *overflow* from the `<body>`\n * and all spacing from fixed items.\n *\n * @param element the target modal/offcanvas\n */\nexport const resetScrollbar = (element?: HTMLElement) => {\n  const bd = getDocumentBody(element);\n  setElementStyle(bd, {\n    paddingRight: '',\n    overflow: '',\n  });\n\n  const fixedItems = getFixedItems(bd);\n\n  if (fixedItems.length) {\n    fixedItems.forEach(fixed => {\n      setElementStyle(fixed, {\n        paddingRight: '',\n        marginRight: '',\n      });\n    });\n  }\n};\n\n/**\n * Returns the scrollbar width if the body does overflow\n * the window.\n *\n * @param element target element\n * @returns the scrollbar width value\n */\nexport const measureScrollbar = (element: HTMLElement) => {\n  const { clientWidth } = getDocumentElement(element);\n  const { innerWidth } = getWindow(element);\n  return Math.abs(innerWidth - clientWidth);\n};\n\n/**\n * Sets the `<body>` and fixed items style when modal / offcanvas\n * is shown to the user.\n *\n * @param element the target modal/offcanvas\n * @param overflow body does overflow or not\n */\nexport const setScrollbar = (element: HTMLElement, overflow?: boolean) => {\n  const bd = getDocumentBody(element);\n  const bodyPad = parseInt(getElementStyle(bd, 'paddingRight'), 10);\n  const isOpen = getElementStyle(bd, 'overflow') === 'hidden';\n  const sbWidth = isOpen && bodyPad ? 0 : measureScrollbar(element);\n  const fixedItems = getFixedItems(bd);\n\n  /* istanbul ignore else */\n  if (overflow) {\n    setElementStyle(bd, {\n      overflow: 'hidden',\n      paddingRight: `${bodyPad + sbWidth}px`,\n    });\n\n    /* istanbul ignore else */\n    if (fixedItems.length) {\n      fixedItems.forEach(fixed => {\n        const itemPadValue = getElementStyle(fixed, 'paddingRight');\n        fixed.style.paddingRight = `${parseInt(itemPadValue, 10) + sbWidth}px`;\n        /* istanbul ignore else */\n        if ([stickyTopClass, positionStickyClass].some(c => hasClass(fixed, c))) {\n          const itemMValue = getElementStyle(fixed, 'marginRight');\n          fixed.style.marginRight = `${parseInt(itemMValue, 10) - sbWidth}px`;\n        }\n      });\n    }\n  }\n};\n","/**\n * Global namespace for components `fixed-top` class.\n */\nconst fixedTopClass = 'fixed-top';\nexport default fixedTopClass;\n","/**\n * Global namespace for components `fixed-bottom` class.\n */\nconst fixedBottomClass = 'fixed-bottom';\nexport default fixedBottomClass;\n","import { getDocumentBody, isNode, createElement } from '@thednp/shorty';\n\n// the default container for Modal, Offcanvas, Popover and Tooltip\nconst popupContainer = createElement({ tagName: 'div', className: 'popup-container' }) as HTMLElement;\n\nconst appendPopup = (target: HTMLElement, customContainer?: ParentNode) => {\n  const containerIsBody = isNode(customContainer) && customContainer.nodeName === 'BODY';\n  const lookup = isNode(customContainer) && !containerIsBody ? customContainer : popupContainer;\n  const BODY = containerIsBody ? customContainer : getDocumentBody(target);\n\n  if (isNode(target)) {\n    if (lookup === popupContainer) {\n      BODY.append(popupContainer);\n    }\n    lookup.append(target);\n  }\n};\n\nconst removePopup = (target: HTMLElement, customContainer?: ParentNode) => {\n  const containerIsBody = isNode(customContainer) && customContainer.nodeName === 'BODY';\n  const lookup = isNode(customContainer) && !containerIsBody ? customContainer : popupContainer;\n\n  if (isNode(target)) {\n    target.remove();\n\n    if (lookup === popupContainer && !popupContainer.children.length) {\n      popupContainer.remove();\n    }\n  }\n};\n\nconst hasPopup = (target: HTMLElement, customContainer?: ParentNode) => {\n  const lookup = isNode(customContainer) && customContainer.nodeName !== 'BODY' ? customContainer : popupContainer;\n  return isNode(target) && lookup.contains(target);\n};\n\nexport { popupContainer, appendPopup, removePopup, hasPopup };\n","import {\n  createElement,\n  getDocument,\n  reflow,\n  removeClass,\n  hasClass,\n  addClass,\n  querySelector,\n  getDocumentBody,\n} from '@thednp/shorty';\n\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport modalString from '../strings/modalString';\nimport offcanvasString from '../strings/offcanvasString';\nimport { resetScrollbar } from './scrollbar';\nimport { appendPopup, removePopup } from './popupContainer';\n\nconst backdropString = 'backdrop';\nconst modalBackdropClass = `${modalString}-${backdropString}`;\nconst offcanvasBackdropClass = `${offcanvasString}-${backdropString}`;\nconst modalActiveSelector = `.${modalString}.${showClass}`;\nconst offcanvasActiveSelector = `.${offcanvasString}.${showClass}`;\n\n// any document would suffice\nconst overlay = createElement('div') as HTMLElement;\n\n/**\n * Returns the current active modal / offcancas element.\n *\n * @param element the context element\n * @returns the requested element\n */\nconst getCurrentOpen = (element?: HTMLElement): HTMLElement | null => {\n  return querySelector(`${modalActiveSelector},${offcanvasActiveSelector}`, getDocument(element));\n};\n\n/**\n * Toogles from a Modal overlay to an Offcanvas, or vice-versa.\n *\n * @param isModal\n */\nconst toggleOverlayType = (isModal?: boolean) => {\n  const targetClass = isModal ? modalBackdropClass : offcanvasBackdropClass;\n  [modalBackdropClass, offcanvasBackdropClass].forEach(c => {\n    removeClass(overlay, c);\n  });\n  addClass(overlay, targetClass);\n};\n\n/**\n * Append the overlay to DOM.\n *\n * @param element\n * @param hasFade\n * @param isModal\n */\nconst appendOverlay = (element: HTMLElement, hasFade: boolean, isModal?: boolean) => {\n  toggleOverlayType(isModal);\n  appendPopup(overlay, getDocumentBody(element));\n  if (hasFade) addClass(overlay, fadeClass);\n};\n\n/**\n * Shows the overlay to the user.\n */\nconst showOverlay = () => {\n  if (!hasClass(overlay, showClass)) {\n    addClass(overlay, showClass);\n    reflow(overlay);\n  }\n};\n\n/**\n * Hides the overlay from the user.\n */\nconst hideOverlay = () => {\n  removeClass(overlay, showClass);\n};\n\n/**\n * Removes the overlay from DOM.\n *\n * @param element\n */\nconst removeOverlay = (element?: HTMLElement): void => {\n  if (!getCurrentOpen(element)) {\n    removeClass(overlay, fadeClass);\n    removePopup(overlay, getDocumentBody(element));\n    resetScrollbar(element);\n  }\n};\n\nexport {\n  overlay,\n  offcanvasBackdropClass,\n  modalBackdropClass,\n  modalActiveSelector,\n  offcanvasActiveSelector,\n  toggleOverlayType,\n  appendOverlay,\n  showOverlay,\n  hideOverlay,\n  getCurrentOpen,\n  removeOverlay,\n};\n","import { isHTMLElement, getElementStyle } from '@thednp/shorty';\n\n/**\n * @param element target\n * @returns the check result\n */\nconst isVisible = (element: HTMLElement) => {\n  return isHTMLElement(element) && getElementStyle(element, 'visibility') !== 'hidden' && element.offsetParent !== null;\n};\nexport default isVisible;\n","/* Native JavaScript for Bootstrap 5 | Modal\n-------------------------------------------- */\nimport {\n  keyEscape,\n  getElementTransitionDuration,\n  removeAttribute,\n  setAttribute,\n  keydownEvent,\n  mouseclickEvent,\n  resizeEvent,\n  ariaModal,\n  ariaHidden,\n  getInstance,\n  isRTL,\n  removeClass,\n  hasClass,\n  addClass,\n  closest,\n  querySelectorAll,\n  querySelector,\n  getDocumentElement,\n  getDocumentBody,\n  getDocument,\n  getWindow,\n  CSS4Declaration,\n  setElementStyle,\n  createCustomEvent,\n  emulateTransitionEnd,\n  passiveHandler,\n  dispatchEvent,\n  focus,\n  Timer,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsToggle from '../strings/dataBsToggle';\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport modalString from '../strings/modalString';\nimport modalComponent from '../strings/modalComponent';\nimport offcanvasComponent from '../strings/offcanvasComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport { setScrollbar, measureScrollbar } from '../util/scrollbar';\nimport {\n  overlay,\n  modalActiveSelector,\n  toggleOverlayType,\n  appendOverlay,\n  showOverlay,\n  hideOverlay,\n  getCurrentOpen,\n  removeOverlay,\n} from '../util/backdrop';\nimport isVisible from '../util/isVisible';\nimport BaseComponent from './base-component';\nimport { ModalOptions, ModalEvent } from '../interface/modal';\nimport { hasPopup } from '../util/popupContainer';\n\n// MODAL PRIVATE GC\n// ================\nconst modalSelector = `.${modalString}`;\nconst modalToggleSelector = `[${dataBsToggle}=\"${modalString}\"]`;\nconst modalDismissSelector = `[${dataBsDismiss}=\"${modalString}\"]`;\nconst modalStaticClass = `${modalString}-static`;\n\nconst modalDefaults = {\n  backdrop: true,\n  keyboard: true,\n};\n\n/**\n * Static method which returns an existing `Modal` instance associated\n * to a target `Element`.\n */\nconst getModalInstance = (element: HTMLElement) => getInstance<Modal>(element, modalComponent);\n\n/**\n * A `Modal` initialization callback.\n */\nconst modalInitCallback = (element: HTMLElement) => new Modal(element);\n\n// MODAL CUSTOM EVENTS\n// ===================\nconst showModalEvent = createCustomEvent<ModalEvent>(`show.bs.${modalString}`);\nconst shownModalEvent = createCustomEvent<ModalEvent>(`shown.bs.${modalString}`);\nconst hideModalEvent = createCustomEvent<ModalEvent>(`hide.bs.${modalString}`);\nconst hiddenModalEvent = createCustomEvent<ModalEvent>(`hidden.bs.${modalString}`);\n\n// MODAL PRIVATE METHODS\n// =====================\n/**\n * Applies special style for the `<body>` and fixed elements\n * when a modal instance is shown to the user.\n *\n * @param self the `Modal` instance\n */\nconst setModalScrollbar = (self: Modal) => {\n  const { element } = self;\n  const scrollbarWidth = measureScrollbar(element);\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  const { clientHeight: modalHeight, scrollHeight: modalScrollHeight } = element;\n  const modalOverflow = modalHeight !== modalScrollHeight;\n\n  /* istanbul ignore else */\n  if (!modalOverflow && scrollbarWidth) {\n    const pad = !isRTL(element) ? 'paddingRight' : /* istanbul ignore next */ 'paddingLeft';\n    const padStyle = {} as Partial<CSS4Declaration>;\n    padStyle[pad] = `${scrollbarWidth}px`;\n    setElementStyle(element, padStyle);\n  }\n  setScrollbar(element, modalOverflow || clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of events that close the modal.\n *\n * @param self the `Modal` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleModalDismiss = (self: Modal, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element, update } = self;\n  action(element, mouseclickEvent, modalDismissHandler as EventListener);\n  action(getWindow(element), resizeEvent, update, passiveHandler);\n  action(getDocument(element), keydownEvent, modalKeyHandler as EventListener);\n};\n\n/**\n * Toggles on/off the `click` event listener of the `Modal` instance.\n *\n * @param self the `Modal` instance\n * @param add when `true`, event listener is added\n */\nconst toggleModalHandler = (self: Modal, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach(btn => action(btn, mouseclickEvent, modalClickHandler as EventListener));\n  }\n};\n\n/**\n * Executes after a modal is hidden to the user.\n *\n * @param self the `Modal` instance\n */\nconst afterModalHide = (self: Modal) => {\n  const { triggers, element, relatedTarget } = self;\n  removeOverlay(element);\n  setElementStyle(element, { paddingRight: '', display: '' });\n  toggleModalDismiss(self);\n\n  const focusElement = showModalEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (focusElement) focus(focusElement as HTMLElement);\n\n  hiddenModalEvent.relatedTarget = relatedTarget as HTMLElement | undefined;\n  dispatchEvent(element, hiddenModalEvent);\n};\n\n/**\n * Executes after a modal is shown to the user.\n *\n * @param self the `Modal` instance\n */\nconst afterModalShow = (self: Modal) => {\n  const { element, relatedTarget } = self;\n  focus(element);\n  toggleModalDismiss(self, true);\n\n  shownModalEvent.relatedTarget = relatedTarget as HTMLElement | undefined;\n  dispatchEvent(element, shownModalEvent);\n};\n\n/**\n * Executes before a modal is shown to the user.\n *\n * @param self the `Modal` instance\n */\nconst beforeModalShow = (self: Modal) => {\n  const { element, hasFade } = self;\n  setElementStyle(element, { display: 'block' });\n\n  setModalScrollbar(self);\n  /* istanbul ignore else */\n  if (!getCurrentOpen(element)) {\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, showClass);\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n\n  if (hasFade) emulateTransitionEnd(element, () => afterModalShow(self));\n  else afterModalShow(self);\n};\n\n/**\n * Executes before a modal is hidden to the user.\n *\n * @param self the `Modal` instance\n */\nconst beforeModalHide = (self: Modal) => {\n  const { element, options, hasFade } = self;\n\n  // callback can also be the transitionEvent object, we wanna make sure it's not\n  // call is not forced and overlay is visible\n  if (options.backdrop && hasFade && hasClass(overlay, showClass) && !getCurrentOpen(element)) {\n    // AND no modal is visible\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => afterModalHide(self));\n  } else {\n    afterModalHide(self);\n  }\n};\n\n// MODAL EVENT HANDLERS\n// ====================\n/**\n * Handles the `click` event listener for modal.\n *\n * @param e the `Event` object\n */\nconst modalClickHandler = (e: MouseEvent) => {\n  const { target } = e;\n\n  const trigger = target && closest(target as HTMLElement, modalToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getModalInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') e.preventDefault();\n    self.relatedTarget = trigger;\n    self.toggle();\n  }\n};\n\n/**\n * Handles the `keydown` event listener for modal\n * to hide the modal when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst modalKeyHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(modalActiveSelector, getDocument(target as Node));\n  const self = element && getModalInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    const { options } = self;\n    /* istanbul ignore else */\n    if (\n      options.keyboard &&\n      code === keyEscape && // the keyboard option is enabled and the key is 27\n      hasClass(element, showClass)\n    ) {\n      // the modal is not visible\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `click` event listeners that hide the modal.\n *\n * @param e the `Event` object\n */\nfunction modalDismissHandler(this: HTMLElement, e: MouseEvent) {\n  const self = getModalInstance(this);\n\n  // this timer is needed\n  /* istanbul ignore else: must have a filter */\n  if (self && !Timer.get(this)) {\n    const { options, isStatic, modalDialog } = self;\n    const { backdrop } = options;\n    const { target } = e;\n\n    const selectedText = getDocument(this)?.getSelection()?.toString().length;\n    const targetInsideDialog = modalDialog.contains(target as HTMLElement);\n    const dismiss = target && closest(target as HTMLElement, modalDismissSelector);\n\n    /* istanbul ignore else */\n    if (isStatic && !targetInsideDialog) {\n      Timer.set(\n        this,\n        () => {\n          addClass(this, modalStaticClass);\n          emulateTransitionEnd(modalDialog, () => staticTransitionEnd(self));\n        },\n        17,\n      );\n    } else if (dismiss || (!selectedText && !isStatic && !targetInsideDialog && backdrop)) {\n      self.relatedTarget = dismiss || null;\n      self.hide();\n      e.preventDefault();\n    }\n  }\n}\n\n/**\n * Handles the `transitionend` event listeners for `Modal`.\n *\n * @param self the `Modal` instance\n */\nconst staticTransitionEnd = (self: Modal) => {\n  const { element, modalDialog } = self;\n  const duration = (getElementTransitionDuration(modalDialog) || 0) + 17;\n  removeClass(element, modalStaticClass);\n  // user must wait for zoom out transition\n  Timer.set(element, () => Timer.clear(element), duration);\n};\n\n// MODAL DEFINITION\n// ================\n/** Returns a new `Modal` instance. */\nexport default class Modal extends BaseComponent {\n  static selector = modalSelector;\n  static init = modalInitCallback;\n  static getInstance = getModalInstance;\n  declare options: ModalOptions;\n  declare modalDialog: HTMLElement;\n  declare triggers: HTMLElement[];\n  declare isStatic: boolean;\n  declare hasFade: boolean;\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually the `.modal` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<ModalOptions>) {\n    super(target, config);\n\n    // the modal\n    const { element } = this;\n\n    // the modal-dialog\n    const modalDialog = querySelector(`.${modalString}-dialog`, element);\n\n    /* istanbul ignore else */\n    if (modalDialog) {\n      this.modalDialog = modalDialog;\n      // modal can have multiple triggering elements\n      this.triggers = [...querySelectorAll(modalToggleSelector, getDocument(element))].filter(\n        btn => getTargetElement(btn) === element,\n      );\n\n      // additional internals\n      this.isStatic = this.options.backdrop === 'static';\n      this.hasFade = hasClass(element, fadeClass);\n      this.relatedTarget = null;\n\n      // attach event listeners\n      toggleModalHandler(this, true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return modalComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return modalDefaults;\n  }\n\n  // MODAL PUBLIC METHODS\n  // ====================\n  /** Toggles the visibility of the modal. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the modal to the user. */\n  show() {\n    const { element, options, hasFade, relatedTarget } = this;\n    const { backdrop } = options;\n    let overlayDelay = 0;\n\n    if (!hasClass(element, showClass)) {\n      showModalEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showModalEvent);\n      if (!showModalEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n\n        if (currentOpen && currentOpen !== element) {\n          const that =\n            getModalInstance(currentOpen) ||\n            /* istanbul ignore next */\n            getInstance<typeof BaseComponent & { hide: () => void }>(currentOpen, offcanvasComponent);\n          if (that) that.hide();\n        }\n        if (backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, hasFade, true);\n          } else {\n            toggleOverlayType(true);\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n          setTimeout(() => beforeModalShow(this), overlayDelay);\n        } else {\n          beforeModalShow(this);\n          /* istanbul ignore else */\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hide the modal from the user. */\n  hide() {\n    const { element, hasFade, relatedTarget } = this;\n\n    if (hasClass(element, showClass)) {\n      hideModalEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideModalEvent);\n\n      if (!hideModalEvent.defaultPrevented) {\n        removeClass(element, showClass);\n        setAttribute(element, ariaHidden, 'true');\n        removeAttribute(element, ariaModal);\n\n        /* istanbul ignore else */\n        if (hasFade) {\n          emulateTransitionEnd(element, () => beforeModalHide(this));\n        } else {\n          beforeModalHide(this);\n        }\n      }\n    }\n  }\n\n  /**\n   * Updates the modal layout.\n   */\n  update = () => {\n    /* istanbul ignore else */\n    if (hasClass(this.element, showClass)) setModalScrollbar(this);\n  };\n\n  /** Removes the `Modal` component from target element. */\n  dispose() {\n    const clone = { ...this };\n    const { element, modalDialog } = clone;\n    const callback = () => setTimeout(() => super.dispose(), 17);\n    toggleModalHandler(clone);\n\n    // use transitionend callback\n    this.hide();\n    /* istanbul ignore else */\n    if (hasClass(element, 'fade')) {\n      emulateTransitionEnd(modalDialog, callback);\n    } else {\n      callback();\n    }\n  }\n}\n","/** @type {string} */\nconst modalComponent = 'Modal';\nexport default modalComponent;\n","/** @type {string} */\nconst offcanvasComponent = 'Offcanvas';\nexport default offcanvasComponent;\n","/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  ariaHidden,\n  addClass,\n  hasClass,\n  closest,\n  querySelectorAll,\n  querySelector,\n  removeAttribute,\n  setAttribute,\n  keyEscape,\n  keydownEvent,\n  mouseclickEvent,\n  ariaModal,\n  emulateTransitionEnd,\n  dispatchEvent,\n  getElementTransitionDuration,\n  getDocumentBody,\n  getDocumentElement,\n  getDocument,\n  removeClass,\n  setElementStyle,\n  createCustomEvent,\n  focus,\n  getInstance,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport showClass from '../strings/showClass';\nimport offcanvasString from '../strings/offcanvasString';\nimport offcanvasComponent from '../strings/offcanvasComponent';\nimport modalComponent from '../strings/modalComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport isVisible from '../util/isVisible';\nimport { setScrollbar } from '../util/scrollbar';\nimport { hasPopup } from '../util/popupContainer';\nimport {\n  overlay,\n  offcanvasActiveSelector,\n  toggleOverlayType,\n  appendOverlay,\n  showOverlay,\n  hideOverlay,\n  getCurrentOpen,\n  removeOverlay,\n} from '../util/backdrop';\nimport BaseComponent from './base-component';\nimport { OffcanvasOptions, OffcanvasEvent } from '../interface/offcanvas';\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: HTMLElement) => getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: HTMLElement) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the `click` event listeners.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true*, listeners are added\n */\nconst toggleOffcanvasEvents = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  self.triggers.forEach(btn => action(btn, mouseclickEvent, offcanvasTriggerHandler as EventListener));\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler as EventListener);\n  action(doc, mouseclickEvent, offcanvasDismissHandler as EventListener);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  /* istanbul ignore else */\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => hideOffcanvasComplete(self));\n  } else hideOffcanvasComplete(self);\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nconst offcanvasTriggerHandler = (e: MouseEvent) => {\n  const trigger = closest(e.target as HTMLElement, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element as HTMLElement | undefined);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    const { options, triggers } = self;\n    const { backdrop } = options;\n    const trigger = closest(target as HTMLElement, offcanvasToggleSelector);\n    const selection = getDocument(element).getSelection();\n\n    /* istanbul ignore else: a filter is required here */\n    if (!overlay.contains(target as HTMLElement) || backdrop !== 'static') {\n      /* istanbul ignore else */\n      if (\n        !(selection && selection.toString().length) &&\n        ((!element.contains(target as HTMLElement) &&\n          backdrop &&\n          /* istanbul ignore next */ (!trigger || triggers.includes(target as HTMLElement))) ||\n          (offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement)))\n      ) {\n        self.relatedTarget =\n          offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement) ? offCanvasDismiss : null;\n        self.hide();\n      }\n\n      /* istanbul ignore next */\n      if (trigger && trigger.tagName === 'A') e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    /* istanbul ignore else */\n    if (self.options.keyboard && code === keyEscape) {\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (visibleTrigger) focus(visibleTrigger as HTMLElement);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<OffcanvasOptions>) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))].filter(\n      btn => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = null;\n\n    // attach event listeners\n    toggleOffcanvasEvents(this, true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    if (!hasClass(element, showClass)) {\n      showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showOffcanvasEvent);\n\n      if (!showOffcanvasEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n        if (currentOpen && currentOpen !== element) {\n          const that =\n            getOffcanvasInstance(currentOpen) ||\n            /* istanbul ignore next */\n            getInstance<typeof BaseComponent & { hide: () => void }>(currentOpen, modalComponent);\n          if (that) that.hide();\n        }\n\n        if (options.backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, true);\n          } else {\n            toggleOverlayType();\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n\n          setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n        } else {\n          beforeOffcanvasShow(this);\n          /* istanbul ignore next - this test was done on Modal */\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n\n    if (hasClass(element, showClass)) {\n      hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideOffcanvasEvent);\n      if (!hideOffcanvasEvent.defaultPrevented) {\n        addClass(element, offcanvasTogglingClass);\n        removeClass(element, showClass);\n        beforeOffcanvasHide(this);\n      }\n    }\n  }\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const clone = { ...this };\n    const { element, options } = clone;\n    const delay = options.backdrop ? getElementTransitionDuration(overlay) : /* istanbul ignore next */ 0;\n    const callback = () => setTimeout(() => super.dispose(), delay + 17);\n    toggleOffcanvasEvents(clone);\n\n    this.hide();\n    if (hasClass(element, showClass)) {\n      emulateTransitionEnd(element, callback);\n      /* istanbul ignore next */\n    } else {\n      callback();\n    }\n  }\n}\n","/** @type {string} */\nconst popoverString = 'popover';\nexport default popoverString;\n","import tooltipString from '../strings/tooltipString';\n\n/**\n * Returns a template for Popover / Tooltip.\n *\n * @param tipType the expected markup type\n * @returns the template markup\n */\nconst getTipTemplate = (tipType: string) => {\n  const isTooltip = tipType === tooltipString;\n  const bodyClass = isTooltip ? `${tipType}-inner` : `${tipType}-body`;\n  const header = !isTooltip ? `<h3 class=\"${tipType}-header\"></h3>` : '';\n  const arrow = `<div class=\"${tipType}-arrow\"></div>`;\n  const body = `<div class=\"${bodyClass}\"></div>`;\n  return `<div class=\"${tipType}\" role=\"${tooltipString}\">${header + arrow + body}</div>`;\n};\n\nexport default getTipTemplate;\n","/** @type {string} */\nconst tooltipString = 'tooltip';\nexport default tooltipString;\n","const tipClassPositions = {\n  top: 'top',\n  bottom: 'bottom',\n  left: 'start',\n  right: 'end',\n};\n\nexport default tipClassPositions;\n","import {\n  isHTMLElement,\n  setElementStyle,\n  getDocumentElement,\n  getBoundingClientRect,\n  getElementStyle,\n  isRTL,\n  toLowerCase,\n  createCustomEvent,\n  dispatchEvent,\n} from '@thednp/shorty';\n\nimport popoverComponent from '../strings/popoverComponent';\nimport tipClassPositions from './tipClassPositions';\nimport Tooltip from '../components/tooltip';\nimport type { TooltipEvent } from '../interface/tooltip';\nimport type { PopoverEvent } from '../interface/popover';\n\n/**\n * Style popovers and tooltips.\n *\n * @param self the `Popover` / `Tooltip` instance\n */\nconst styleTip = <T extends Tooltip>(self: T) => {\n  const tipClasses = /\\b(top|bottom|start|end)+/;\n  const { element, tooltip, container, options, arrow } = self;\n\n  /* istanbul ignore else */\n  if (tooltip) {\n    const tipPositions = { ...tipClassPositions };\n    const RTL = isRTL(element);\n\n    // reset tooltip style (top: 0, left: 0 works best)\n    setElementStyle(tooltip, {\n      // top: '0px', left: '0px', right: '', bottom: '',\n      top: '',\n      left: '',\n      right: '',\n      bottom: '',\n    });\n    const isPopover = self.name === popoverComponent;\n    const { offsetWidth: tipWidth, offsetHeight: tipHeight } = tooltip;\n    const { clientWidth: htmlcw, clientHeight: htmlch, offsetWidth: htmlow } = getDocumentElement(element);\n    let { placement } = options;\n    const { clientWidth: parentCWidth, offsetWidth: parentOWidth } = container as HTMLElement;\n    const parentPosition = getElementStyle(container as HTMLElement, 'position');\n    const fixedParent = parentPosition === 'fixed';\n    const scrollbarWidth = fixedParent ? Math.abs(parentCWidth - parentOWidth) : Math.abs(htmlcw - htmlow);\n    const leftBoundry = RTL && fixedParent ? /* istanbul ignore next */ scrollbarWidth : 0;\n    const rightBoundry = htmlcw - (!RTL ? scrollbarWidth : 0) - 1;\n    const {\n      width: elemWidth,\n      height: elemHeight,\n      left: elemRectLeft,\n      right: elemRectRight,\n      top: elemRectTop,\n    } = getBoundingClientRect(element, true);\n    const { x, y } = {\n      x: elemRectLeft,\n      y: elemRectTop,\n    };\n    // reset arrow style\n    setElementStyle(arrow as HTMLElement, {\n      top: '',\n      left: '',\n      right: '',\n      bottom: '',\n    });\n    let topPosition: number | string = 0;\n    let bottomPosition: number | string = '';\n    let leftPosition: number | string = 0;\n    let rightPosition: number | string = '';\n    let arrowTop: number | string = '';\n    let arrowLeft: number | string = '';\n    let arrowRight: number | string = '';\n\n    const arrowWidth = (arrow as HTMLElement).offsetWidth || 0;\n    const arrowHeight = (arrow as HTMLElement).offsetHeight || 0;\n    const arrowAdjust = arrowWidth / 2;\n\n    // check placement\n    let topExceed = elemRectTop - tipHeight - arrowHeight < 0;\n    let bottomExceed = elemRectTop + tipHeight + elemHeight + arrowHeight >= htmlch;\n    let leftExceed = elemRectLeft - tipWidth - arrowWidth < leftBoundry;\n    let rightExceed = elemRectLeft + tipWidth + elemWidth + arrowWidth >= rightBoundry;\n\n    const horizontals = ['left', 'right'];\n    const verticals = ['top', 'bottom'];\n\n    topExceed = horizontals.includes(placement)\n      ? elemRectTop + elemHeight / 2 - tipHeight / 2 - arrowHeight < 0\n      : topExceed;\n    bottomExceed = horizontals.includes(placement)\n      ? elemRectTop + tipHeight / 2 + elemHeight / 2 + arrowHeight >= htmlch\n      : bottomExceed;\n    leftExceed = verticals.includes(placement) ? elemRectLeft + elemWidth / 2 - tipWidth / 2 < leftBoundry : leftExceed;\n    rightExceed = verticals.includes(placement)\n      ? elemRectLeft + tipWidth / 2 + elemWidth / 2 >= rightBoundry\n      : rightExceed;\n\n    // first remove side positions if both left and right limits are exceeded\n    // we usually fall back to top|bottom\n    placement = horizontals.includes(placement) && leftExceed && rightExceed ? 'top' : placement;\n    // recompute placement\n    placement = placement === 'top' && topExceed ? 'bottom' : placement;\n    placement = placement === 'bottom' && bottomExceed ? 'top' : placement;\n    placement = placement === 'left' && leftExceed ? 'right' : placement;\n    placement = placement === 'right' && rightExceed ? /* istanbul ignore next */ 'left' : placement;\n\n    // update tooltip/popover class\n    if (!tooltip.className.includes(placement)) {\n      tooltip.className = tooltip.className.replace(tipClasses, tipPositions[placement]);\n    }\n\n    // compute tooltip / popover coordinates\n    /* istanbul ignore else */\n    if (horizontals.includes(placement)) {\n      // secondary|side positions\n      if (placement === 'left') {\n        // LEFT\n        leftPosition = x - tipWidth - (isPopover ? arrowWidth : 0);\n      } else {\n        // RIGHT\n        leftPosition = x + elemWidth + (isPopover ? arrowWidth : 0);\n      }\n\n      // adjust top and arrow\n      if (topExceed && bottomExceed) {\n        topPosition = 0;\n        bottomPosition = 0;\n        arrowTop = elemRectTop + elemHeight / 2 - arrowHeight / 2;\n      } else if (topExceed) {\n        topPosition = y;\n        bottomPosition = '';\n        arrowTop = elemHeight / 2 - arrowWidth;\n      } else if (bottomExceed) {\n        topPosition = y - tipHeight + elemHeight;\n        bottomPosition = '';\n        arrowTop = tipHeight - elemHeight / 2 - arrowWidth;\n      } else {\n        topPosition = y - tipHeight / 2 + elemHeight / 2;\n        arrowTop = tipHeight / 2 - arrowHeight / 2;\n      }\n    } else if (verticals.includes(placement)) {\n      if (placement === 'top') {\n        topPosition = y - tipHeight - (isPopover ? arrowHeight : 0);\n      } else {\n        // BOTTOM\n        topPosition = y + elemHeight + (isPopover ? arrowHeight : 0);\n      }\n\n      // adjust left | right and also the arrow\n      if (leftExceed) {\n        leftPosition = 0;\n        arrowLeft = x + elemWidth / 2 - arrowAdjust;\n      } else if (rightExceed) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = elemWidth / 2 + rightBoundry - elemRectRight - arrowAdjust;\n      } else {\n        leftPosition = x - tipWidth / 2 + elemWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    }\n\n    // apply style to tooltip/popover\n    setElementStyle(tooltip, {\n      top: `${topPosition}px`,\n      bottom: bottomPosition === '' ? '' : `${bottomPosition}px`,\n      left: leftPosition === 'auto' ? leftPosition : `${leftPosition}px`,\n      right: rightPosition !== '' ? `${rightPosition}px` : '',\n    });\n\n    // update arrow placement\n    /* istanbul ignore else */\n    if (isHTMLElement(arrow)) {\n      if (arrowTop !== '') {\n        arrow.style.top = `${arrowTop}px`;\n      }\n      if (arrowLeft !== '') {\n        arrow.style.left = `${arrowLeft}px`;\n      } else if (arrowRight !== '') {\n        arrow.style.right = `${arrowRight}px`;\n      }\n    }\n    const updatedTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`updated.bs.${toLowerCase(self.name)}`);\n    dispatchEvent(element, updatedTooltipEvent);\n  }\n};\n\nexport default styleTip;\n","/** @type {string} */\nconst popoverComponent = 'Popover';\nexport default popoverComponent;\n","import getTipTemplate from './getTipTemplate';\nimport tooltipString from '../strings/tooltipString';\nimport { TooltipOptions } from '../interface/tooltip';\n\nconst tooltipDefaults: TooltipOptions = {\n  template: getTipTemplate(tooltipString),\n  title: '',\n  customClass: '',\n  trigger: 'hover focus',\n  placement: 'top',\n  sanitizeFn: undefined,\n  animation: true,\n  delay: 200,\n  container: document.body,\n  content: '',\n  dismissible: false,\n  btnClose: '',\n};\nexport default tooltipDefaults;\n","import { isNode, isArray, isFunction, isString, isNodeList, isHTMLElement } from '@thednp/shorty';\n\n/**\n * Append an existing `Element` to Popover / Tooltip component or HTML\n * markup string to be parsed & sanitized to be used as popover / tooltip content.\n *\n * @param element target\n * @param content the `Element` to append / string\n * @param sanitizeFn a function to sanitize string content\n */\nconst setHtml = (element: HTMLElement, content: Node[] | Node | string, sanitizeFn?: (s: string) => string) => {\n  /* istanbul ignore else */\n  if (isString(content) && content.length) {\n    let dirty = content.trim(); // fixing #233\n    if (isFunction(sanitizeFn)) dirty = sanitizeFn(dirty);\n\n    const domParser = new DOMParser();\n    const tempDocument = domParser.parseFromString(dirty, 'text/html');\n    element.append(...[...tempDocument.body.childNodes]);\n  } else if (isHTMLElement(content)) {\n    element.append(content);\n  } else if (isNodeList(content) || (isArray(content) && content.every(isNode))) {\n    element.append(...[...content]);\n  }\n};\nexport default setHtml;\n","/* Native JavaScript for Bootstrap 5 | Tooltip\n---------------------------------------------- */\nimport {\n  ariaDescribedBy,\n  focusoutEvent,\n  focusinEvent,\n  focusEvent,\n  mouseleaveEvent,\n  mouseenterEvent,\n  mousedownEvent,\n  mouseclickEvent,\n  closest,\n  getUID,\n  getDocument,\n  getWindow,\n  removeAttribute,\n  getAttribute,\n  setAttribute,\n  hasAttribute,\n  touchstartEvent,\n  resizeEvent,\n  scrollEvent,\n  mousehoverEvent,\n  toLowerCase,\n  focus,\n  Timer,\n  emulateTransitionEnd,\n  passiveHandler,\n  dispatchEvent,\n  isApple,\n  getInstance,\n  ObjectAssign,\n  createCustomEvent,\n  removeClass,\n  hasClass,\n  addClass,\n  getElementStyle,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsToggle from '../strings/dataBsToggle';\nimport dataOriginalTitle from '../strings/dataOriginalTitle';\nimport showClass from '../strings/showClass';\nimport tooltipString from '../strings/tooltipString';\nimport tooltipComponent from '../strings/tooltipComponent';\nimport popoverString from '../strings/popoverString';\nimport popoverComponent from '../strings/popoverComponent';\nimport modalString from '../strings/modalString';\nimport offcanvasString from '../strings/offcanvasString';\n\nimport styleTip from '../util/styleTip';\nimport createTip from '../util/createTip';\nimport { appendPopup, removePopup, hasPopup } from '../util/popupContainer';\nimport getElementContainer from '../util/getElementContainer';\nimport tooltipDefaults from '../util/tooltipDefaults';\nimport BaseComponent from './base-component';\nimport { TooltipOptions, TooltipEvent } from '../interface/tooltip';\nimport { PopoverOptions, PopoverEvent } from '../interface/popover';\n\n// TOOLTIP PRIVATE GC\n// ==================\nconst tooltipSelector = `[${dataBsToggle}=\"${tooltipString}\"],[data-tip=\"${tooltipString}\"]`;\nconst titleAttr = 'title';\n\n/**\n * Static method which returns an existing `Tooltip` instance associated\n * to a target `Element`.\n *\n */\nlet getTooltipInstance = (element: HTMLElement) => getInstance<Tooltip>(element, tooltipComponent);\n\n/**\n * A `Tooltip` initialization callback.\n */\nconst tooltipInitCallback = (element: HTMLElement) => new Tooltip(element);\n\n// TOOLTIP PRIVATE METHODS\n// =======================\n/**\n * Removes the tooltip from the DOM.\n *\n * @param self the `Tooltip` instance\n */\nconst removeTooltip = (self: Tooltip) => {\n  const { element, tooltip, container, offsetParent } = self;\n  removeAttribute(element, ariaDescribedBy);\n  removePopup(tooltip as HTMLElement, container === offsetParent ? container : offsetParent);\n};\n\n/**\n * Check if container contains the tooltip.\n *\n * @param self Tooltip\n */\nconst hasTip = (self: Tooltip): boolean | undefined => {\n  const { tooltip, container, offsetParent } = self;\n\n  return tooltip && hasPopup(tooltip, container === offsetParent ? container : offsetParent);\n};\n\n/**\n * Executes after the instance has been disposed.\n *\n * @param self the `Tooltip` instance\n * @param callback the parent dispose callback\n */\nconst disposeTooltipComplete = (self: Tooltip, callback?: () => void) => {\n  const { element } = self;\n  toggleTooltipHandlers(self);\n\n  /* istanbul ignore else */\n  if (hasAttribute(element, dataOriginalTitle) && self.name === tooltipComponent) {\n    toggleTooltipTitle(self);\n  }\n  /* istanbul ignore else */\n  if (callback) callback();\n};\n\n/**\n * Toggles on/off the special `Tooltip` event listeners.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipAction = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n\n  action(getDocument(element), touchstartEvent, self.handleTouch as EventListener, passiveHandler);\n\n  [scrollEvent, resizeEvent].forEach(ev => {\n    action(getWindow(element), ev, self.update, passiveHandler);\n  });\n};\n\n/**\n * Executes after the tooltip was shown to the user.\n *\n * @param self the `Tooltip` instance\n */\nconst tooltipShownAction = (self: Tooltip) => {\n  const { element } = self;\n  const shownTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`shown.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self, true);\n  dispatchEvent(element, shownTooltipEvent);\n  Timer.clear(element, 'in');\n};\n\n/**\n * Executes after the tooltip was hidden to the user.\n *\n * @param self the `Tooltip` instance\n */\nconst tooltipHiddenAction = (self: Tooltip) => {\n  const { element } = self;\n  const hiddenTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`hidden.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self);\n  removeTooltip(self);\n  dispatchEvent(element, hiddenTooltipEvent);\n\n  Timer.clear(element, 'out');\n};\n\n/**\n * Toggles on/off the `Tooltip` event listeners.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipHandlers = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  // btn is only for dismissible popover\n  const { element, options, btn } = self;\n  const { trigger } = options;\n  const isPopover = self.name !== tooltipComponent;\n  const dismissible = isPopover && (options as PopoverOptions).dismissible ? true : false;\n\n  /* istanbul ignore else */\n  if (!trigger.includes('manual')) {\n    self.enabled = !!add;\n\n    const triggerOptions = trigger.split(' ');\n\n    triggerOptions.forEach(tr => {\n      /* istanbul ignore else */\n      if (tr === mousehoverEvent) {\n        action(element, mousedownEvent, self.handleShow);\n        action(element, mouseenterEvent, self.handleShow);\n\n        /* istanbul ignore else */\n        if (!dismissible) {\n          action(element, mouseleaveEvent, self.handleHide);\n          action(getDocument(element), touchstartEvent, self.handleTouch as EventListener, passiveHandler);\n        }\n      } else if (tr === mouseclickEvent) {\n        action(element, tr, !dismissible ? self.toggle : self.handleShow);\n      } else if (tr === focusEvent) {\n        action(element, focusinEvent, self.handleShow);\n        /* istanbul ignore else */\n        if (!dismissible) action(element, focusoutEvent, self.handleHide);\n        /* istanbul ignore else */\n        if (isApple) {\n          action(element, mouseclickEvent, self.handleFocus);\n        }\n      }\n      /* istanbul ignore else */\n      if (dismissible && btn) {\n        action(btn, mouseclickEvent, self.handleHide);\n      }\n    });\n  }\n};\n\n/**\n * Toggles on/off the `Tooltip` event listeners that hide/update the tooltip.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipOpenHandlers = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element, container, offsetParent } = self;\n  const { offsetHeight, scrollHeight } = container as HTMLElement;\n  const parentModal = closest(element, `.${modalString}`);\n  const parentOffcanvas = closest(element, `.${offcanvasString}`);\n\n  /* istanbul ignore else */\n  const win = getWindow(element);\n  const overflow = offsetHeight !== scrollHeight;\n  const scrollTarget = container === offsetParent && overflow ? container : win;\n  action(scrollTarget, resizeEvent, self.update, passiveHandler);\n  action(scrollTarget, scrollEvent, self.update, passiveHandler);\n\n  // dismiss tooltips inside modal / offcanvas\n  if (parentModal) action(parentModal, `hide.bs.${modalString}`, self.handleHide);\n  if (parentOffcanvas) action(parentOffcanvas, `hide.bs.${offcanvasString}`, self.handleHide);\n};\n\n/**\n * Toggles the `title` and `data-original-title` attributes.\n *\n * @param self the `Tooltip` instance\n * @param content when `true`, event listeners are added\n */\nconst toggleTooltipTitle = (self: Tooltip, content?: string) => {\n  // [0 - add, 1 - remove] | [0 - remove, 1 - add]\n  const titleAtt = [dataOriginalTitle, titleAttr];\n  const { element } = self;\n\n  setAttribute(\n    element,\n    titleAtt[content ? 0 : 1],\n    content || getAttribute(element, titleAtt[0]) || /* istanbul ignore next */ '',\n  );\n  removeAttribute(element, titleAtt[content ? 1 : 0]);\n};\n\n// TOOLTIP DEFINITION\n// ==================\n/** Creates a new `Tooltip` instance. */\nexport default class Tooltip extends BaseComponent {\n  static selector = tooltipSelector;\n  static init = tooltipInitCallback;\n  static getInstance = getTooltipInstance;\n  static styleTip = styleTip;\n  declare options: TooltipOptions;\n  declare btn?: HTMLElement;\n  declare tooltip?: HTMLElement;\n  declare container: ParentNode;\n  declare arrow?: HTMLElement;\n  declare offsetParent?: HTMLElement;\n  declare enabled: boolean;\n  declare id: string;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<TooltipOptions>) {\n    super(target, config);\n\n    const { element } = this;\n    const isTooltip = this.name === tooltipComponent;\n    const tipString = isTooltip ? tooltipString : popoverString;\n    const tipComponent = isTooltip ? tooltipComponent : popoverComponent;\n\n    /* istanbul ignore next: this is to set Popover too */\n    getTooltipInstance = <T extends Tooltip>(elem: HTMLElement) => getInstance<T>(elem, tipComponent);\n\n    // additional properties\n    this.enabled = true;\n    /** Set unique ID for `aria-describedby`. */\n    this.id = `${tipString}-${getUID(element, tipString)}`;\n\n    // instance options\n    const { options } = this;\n\n    // invalidate\n    if (!((!options.title && isTooltip) || (!isTooltip && !options.content))) {\n      // reset default options\n      ObjectAssign(tooltipDefaults, { titleAttr: '' });\n\n      // set title attributes and add event listeners\n      /* istanbul ignore else */\n      if (hasAttribute(element, titleAttr) && isTooltip && typeof options.title === 'string') {\n        toggleTooltipTitle(this, options.title);\n      }\n\n      // set containers\n      this.container = getElementContainer(element);\n      this.offsetParent = ['sticky', 'fixed'].some(\n        position => getElementStyle(this.container as HTMLElement, 'position') === position,\n      )\n        ? (this.container as HTMLElement)\n        : getDocument(this.element).body;\n\n      // create tooltip here\n      createTip(this);\n\n      // attach events\n      toggleTooltipHandlers(this, true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return tooltipComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return tooltipDefaults;\n  }\n\n  // TOOLTIP PUBLIC METHODS\n  // ======================\n  /** Handles the focus event on iOS. */\n  handleFocus = () => focus(this.element);\n  /** Shows the tooltip. */\n  handleShow = () => this.show();\n  show() {\n    const { options, tooltip, element, container, offsetParent, id } = this;\n    const { animation } = options;\n    const outTimer = Timer.get(element, 'out');\n    const tipContainer = container === offsetParent ? container : offsetParent;\n\n    Timer.clear(element, 'out');\n\n    if (tooltip && !outTimer && !hasTip(this)) {\n      Timer.set(\n        element,\n        () => {\n          const showTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`show.bs.${toLowerCase(this.name)}`);\n          dispatchEvent(element, showTooltipEvent);\n          if (!showTooltipEvent.defaultPrevented) {\n            // append to container\n            appendPopup(tooltip, tipContainer);\n\n            setAttribute(element, ariaDescribedBy, `#${id}`);\n\n            this.update();\n            toggleTooltipOpenHandlers(this, true);\n\n            /* istanbul ignore else */\n            if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);\n            /* istanbul ignore else */\n            if (animation) emulateTransitionEnd(tooltip, () => tooltipShownAction(this));\n            else tooltipShownAction(this);\n          }\n        },\n        17,\n        'in',\n      );\n    }\n  }\n\n  /** Hides the tooltip. */\n  handleHide = () => this.hide();\n  hide() {\n    const { options, tooltip, element } = this;\n    const { animation, delay } = options;\n\n    Timer.clear(element, 'in');\n\n    /* istanbul ignore else */\n    if (tooltip && hasTip(this)) {\n      Timer.set(\n        element,\n        () => {\n          const hideTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`hide.bs.${toLowerCase(this.name)}`);\n          dispatchEvent(element, hideTooltipEvent);\n\n          if (!hideTooltipEvent.defaultPrevented) {\n            this.update();\n            removeClass(tooltip, showClass);\n            toggleTooltipOpenHandlers(this);\n\n            /* istanbul ignore else */\n            if (animation) emulateTransitionEnd(tooltip, () => tooltipHiddenAction(this));\n            else tooltipHiddenAction(this);\n          }\n        },\n        delay + 17,\n        'out',\n      );\n    }\n  }\n\n  /** Updates the tooltip position. */\n  update = () => {\n    styleTip<Tooltip>(this);\n  };\n\n  /** Toggles the tooltip visibility. */\n  toggle = () => {\n    const { tooltip } = this;\n\n    if (tooltip && !hasTip(this)) this.show();\n    else this.hide();\n  };\n\n  /** Enables the tooltip. */\n  enable() {\n    const { enabled } = this;\n    /* istanbul ignore else */\n    if (!enabled) {\n      toggleTooltipHandlers(this, true);\n      this.enabled = !enabled;\n    }\n  }\n\n  /** Disables the tooltip. */\n  disable() {\n    const { tooltip, options, enabled } = this;\n    const { animation } = options;\n    /* istanbul ignore else */\n    if (enabled) {\n      if (tooltip && hasTip(this) && animation) {\n        this.hide();\n        emulateTransitionEnd(tooltip, () => toggleTooltipHandlers(this));\n      } else {\n        toggleTooltipHandlers(this);\n      }\n      this.enabled = !enabled;\n    }\n  }\n\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    if (!this.enabled) this.enable();\n    else this.disable();\n  }\n\n  /**\n   * Handles the `touchstart` event listener for `Tooltip`\n   *\n   * @this {Tooltip}\n   * @param {TouchEvent} e the `Event` object\n   */\n  handleTouch = ({ target }: TouchEvent) => {\n    const { tooltip, element } = this;\n\n    /* istanbul ignore else */\n    if (\n      (tooltip && tooltip.contains(target as HTMLElement)) ||\n      target === element ||\n      (target && element.contains(target as HTMLElement))\n    ) {\n      // smile for ESLint\n    } else {\n      this.hide();\n    }\n  };\n\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const { tooltip, options } = this;\n    const clone = { ...this, name: this.name };\n    const callback = () => setTimeout(() => disposeTooltipComplete(clone, () => super.dispose()), 17);\n\n    if (options.animation && hasTip(clone)) {\n      this.options.delay = 0; // reset delay\n      this.hide();\n      emulateTransitionEnd(tooltip as HTMLElement, callback);\n    } else {\n      callback();\n    }\n  }\n}\n","/** @type {string} */\nconst tooltipComponent = 'Tooltip';\nexport default tooltipComponent;\n","/**\n * Global namespace for `data-bs-title` attribute.\n */\nconst dataOriginalTitle = 'data-original-title';\nexport default dataOriginalTitle;\n","import { getDocument, isShadowRoot, isTableElement, getParentNode, getElementStyle } from '@thednp/shorty';\n\n/**\n * Returns an `HTMLElement` to be used as default value for *options.container*\n * for `Tooltip` / `Popover` components.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param element the target\n * @returns the query result\n */\nconst getElementContainer = (element: HTMLElement): ParentNode => {\n  const majorBlockTags = ['HTML', 'BODY'];\n  const containers: ParentNode[] = [];\n  let { parentNode } = element as Node;\n\n  while (parentNode && !majorBlockTags.includes(parentNode.nodeName)) {\n    parentNode = getParentNode(parentNode) as ParentNode;\n    /* istanbul ignore else */\n    if (!(isShadowRoot(parentNode) || isTableElement(parentNode))) {\n      containers.push(parentNode);\n    }\n  }\n\n  return (\n    containers.find((c, i) => {\n      if (\n        getElementStyle(c as HTMLElement, 'position') !== 'relative' &&\n        containers.slice(i + 1).every(r => getElementStyle(r as HTMLElement, 'position') === 'static')\n      ) {\n        return c;\n      }\n      return null;\n    }) || /* istanbul ignore next: optional guard */ getDocument(element).body\n  );\n};\n\nexport default getElementContainer;\n","import { createElement, addClass, hasClass, setAttribute, querySelector, isRTL, isHTMLElement } from '@thednp/shorty';\n\nimport tooltipComponent from '../strings/tooltipComponent';\nimport tooltipString from '../strings/tooltipString';\nimport popoverString from '../strings/popoverString';\nimport fadeClass from '../strings/fadeClass';\nimport tipClassPositions from './tipClassPositions';\nimport setHtml from './setHtml';\nimport Tooltip from '../components/tooltip';\nimport Popover from '../components/popover';\n\n/**\n * Creates a new tooltip / popover.\n *\n * @param self the `Tooltip` / `Popover` instance\n */\nconst createTip = (self: Tooltip | Popover) => {\n  const isTooltip = self.name === tooltipComponent;\n\n  const { id, element, options } = self;\n  const { title, placement, template, animation, customClass, sanitizeFn, dismissible, content, btnClose } = options;\n  const tipString = isTooltip ? tooltipString : popoverString;\n  const tipPositions = { ...tipClassPositions };\n  let titleParts: Node[] = [];\n  let contentParts: Node[] = [];\n\n  if (isRTL(element)) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // set initial popover class\n  const placementClass = `bs-${tipString}-${tipPositions[placement]}`;\n\n  // load template\n  let tooltipTemplate: Node | string;\n  if (isHTMLElement(template)) {\n    tooltipTemplate = template;\n  } else {\n    const htmlMarkup = createElement('div') as HTMLElement;\n    setHtml(htmlMarkup, template, sanitizeFn);\n    tooltipTemplate = htmlMarkup.firstChild as HTMLElement;\n  }\n\n  // set popover markup\n  self.tooltip = isHTMLElement(tooltipTemplate)\n    ? (tooltipTemplate.cloneNode(true) as HTMLElement)\n    : /* istanbul ignore next */ undefined;\n\n  const { tooltip } = self;\n  /* istanbul ignore else */\n  if (tooltip) {\n    // set id and role attributes\n    setAttribute(tooltip, 'id', id);\n    setAttribute(tooltip, 'role', tooltipString);\n\n    const bodyClass = isTooltip ? `${tooltipString}-inner` : `${popoverString}-body`;\n    const tooltipHeader = isTooltip ? null : querySelector(`.${popoverString}-header`, tooltip);\n    const tooltipBody = querySelector(`.${bodyClass}`, tooltip);\n\n    // set arrow and enable access for styleTip\n    self.arrow = querySelector(`.${tipString}-arrow`, tooltip) as HTMLElement;\n    const { arrow } = self;\n\n    if (isHTMLElement(title)) titleParts = [title.cloneNode(true)];\n    else {\n      const tempTitle = createElement('div') as HTMLElement;\n      setHtml(tempTitle, title, sanitizeFn);\n      titleParts = [...[...tempTitle.childNodes]];\n    }\n\n    if (isHTMLElement(content)) contentParts = [content.cloneNode(true)];\n    else {\n      const tempContent = createElement('div') as HTMLElement;\n      setHtml(tempContent, content, sanitizeFn);\n      contentParts = [...[...tempContent.childNodes]];\n    }\n\n    // set dismissible button\n    if (dismissible) {\n      if (title) {\n        if (isHTMLElement(btnClose)) titleParts = [...titleParts, btnClose.cloneNode(true)];\n        else {\n          const tempBtn = createElement('div') as HTMLElement;\n          setHtml(tempBtn, btnClose, sanitizeFn);\n          titleParts = [...titleParts, tempBtn.firstChild as Node];\n        }\n      } else {\n        /* istanbul ignore else */\n        if (tooltipHeader) tooltipHeader.remove();\n        if (isHTMLElement(btnClose)) contentParts = [...contentParts, btnClose.cloneNode(true)];\n        else {\n          const tempBtn = createElement('div') as HTMLElement;\n          setHtml(tempBtn, btnClose, sanitizeFn);\n          contentParts = [...contentParts, tempBtn.firstChild as Node];\n        }\n      }\n    }\n\n    // fill the template with content from options / data attributes\n    // also sanitize title && content\n    /* istanbul ignore else */\n    if (!isTooltip) {\n      /* istanbul ignore else */\n      if (title && tooltipHeader) setHtml(tooltipHeader, titleParts, sanitizeFn);\n      /* istanbul ignore else */\n      if (content && tooltipBody) setHtml(tooltipBody, contentParts, sanitizeFn);\n      // set btn\n      self.btn = querySelector('.btn-close', tooltip) || undefined;\n    } else if (title && tooltipBody) setHtml(tooltipBody, title, sanitizeFn);\n\n    // Bootstrap 5.2.x\n    // addClass(tooltip, 'position-absolute');\n    addClass(tooltip, 'position-fixed');\n    addClass(arrow, 'position-absolute');\n\n    // set popover animation and placement\n    /* istanbul ignore else */\n    if (!hasClass(tooltip, tipString)) addClass(tooltip, tipString);\n    /* istanbul ignore else */\n    if (animation && !hasClass(tooltip, fadeClass)) addClass(tooltip, fadeClass);\n    /* istanbul ignore else */\n    if (customClass && !hasClass(tooltip, customClass)) {\n      addClass(tooltip, customClass);\n    }\n    /* istanbul ignore else */\n    if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);\n  }\n};\n\nexport default createTip;\n","/* Native JavaScript for Bootstrap 5 | Popover\n---------------------------------------------- */\nimport { getInstance, ObjectAssign, focus } from '@thednp/shorty';\n\nimport dataBsToggle from '../strings/dataBsToggle';\nimport popoverString from '../strings/popoverString';\nimport popoverComponent from '../strings/popoverComponent';\n\nimport getTipTemplate from '../util/getTipTemplate';\nimport styleTip from '../util/styleTip';\nimport tooltipDefaults from '../util/tooltipDefaults';\nimport Tooltip from './tooltip';\n\nimport type { PopoverOptions /* , PopoverEvent */ } from '../interface/popover';\n\n// POPOVER PRIVATE GC\n// ==================\nconst popoverSelector = `[${dataBsToggle}=\"${popoverString}\"],[data-tip=\"${popoverString}\"]`;\n\nconst popoverDefaults: PopoverOptions = ObjectAssign({}, tooltipDefaults, {\n  template: getTipTemplate(popoverString),\n  content: '',\n  dismissible: false,\n  btnClose: '<button class=\"btn-close\" aria-label=\"Close\"></button>',\n});\n\n/**\n * Static method which returns an existing `Popover` instance associated\n * to a target `Element`.\n *\n */\nconst getPopoverInstance = (element: HTMLElement) => getInstance<Popover>(element, popoverComponent);\n\n/**\n * A `Popover` initialization callback.\n */\nconst popoverInitCallback = (element: HTMLElement) => new Popover(element);\n\n// POPOVER DEFINITION\n// ==================\n/** Returns a new `Popover` instance. */\nexport default class Popover extends Tooltip {\n  static selector = popoverSelector;\n  static init = popoverInitCallback;\n  static getInstance = getPopoverInstance;\n  static styleTip = styleTip;\n  declare options: PopoverOptions;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<PopoverOptions>) {\n    super(target, config);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return popoverComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return popoverDefaults;\n  }\n\n  /* extend original `show()` */\n  show = () => {\n    super.show();\n    // btn only exists within dismissible popover\n    const { options, btn } = this;\n    /* istanbul ignore else */\n    if (options.dismissible && btn) setTimeout(() => focus(btn), 17);\n  };\n}\n","/** @type {string} */\nconst scrollspyString = 'scrollspy';\nexport default scrollspyString;\n","/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\nimport {\n  getDocumentBody,\n  getDocumentElement,\n  getDocument,\n  getWindow,\n  removeClass,\n  hasClass,\n  addClass,\n  getElementsByTagName,\n  getAttribute,\n  querySelector,\n  isHTMLElement,\n  isWindow,\n  createCustomEvent,\n  getInstance,\n  scrollEvent,\n  // ObjectAssign,\n  passiveHandler,\n  dispatchEvent,\n  getBoundingClientRect,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport activeClass from '../strings/activeClass';\nimport scrollspyString from '../strings/scrollspyString';\nimport scrollspyComponent from '../strings/scrollspyComponent';\n\nimport BaseComponent from './base-component';\nimport { ScrollSpyOptions, ScrollSpyEvent } from '../interface/scrollspy';\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults: ScrollSpyOptions = {\n  offset: 10,\n  target: null,\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n */\nconst getScrollSpyInstance = (element: HTMLElement) => getInstance<ScrollSpy>(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n */\nconst scrollspyInitCallback = (element: HTMLElement) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = createCustomEvent<ScrollSpyEvent>(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n *\n * @param self the `ScrollSpy` instance\n */\nconst updateSpyTargets = (self: ScrollSpy) => {\n  const { target, scrollTarget, options, itemsLength, scrollHeight, element } = self;\n  const { offset } = options;\n  const isWin = isWindow(scrollTarget as Node | Window);\n\n  const links = target && getElementsByTagName('A', target);\n  const scrollHEIGHT = scrollTarget ? getScrollHeight(scrollTarget) : /* istanbul ignore next */ scrollHeight;\n\n  self.scrollTop = isWin ? (scrollTarget as Window).scrollY : (scrollTarget as HTMLElement).scrollTop;\n\n  // only update items/offsets once or with each mutation\n  /* istanbul ignore else */\n  if (links && (scrollHEIGHT !== scrollHeight || itemsLength !== links.length)) {\n    let href;\n    let targetItem;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    [...links].forEach(link => {\n      href = getAttribute(link, 'href');\n      targetItem =\n        href && href.charAt(0) === '#' && href.slice(-1) !== '#' && querySelector(href, getDocument(element));\n\n      if (targetItem) {\n        self.items.push(link);\n        rect = getBoundingClientRect(targetItem);\n        self.offsets.push((isWin ? rect.top + self.scrollTop : targetItem.offsetTop) - offset);\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n};\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n *\n * @param scrollTarget the `ScrollSpy` instance\n * @return `scrollTarget` height\n */\nconst getScrollHeight = (scrollTarget: Node | Window) => {\n  return isHTMLElement(scrollTarget as Node)\n    ? (scrollTarget as HTMLElement).scrollHeight\n    : getDocumentElement(scrollTarget as Node).scrollHeight;\n};\n\n/**\n * Returns the height property of the scrolling element.\n *\n * @param params the `ScrollSpy` instance\n */\nconst getOffsetHeight = ({ element, scrollTarget }: ScrollSpy) => {\n  return isWindow(scrollTarget as Node) ? (scrollTarget as Window).innerHeight : getBoundingClientRect(element).height;\n};\n\n/**\n * Clear all items of the target.\n *\n * @param target a single item\n */\nconst clear = (target: HTMLElement) => {\n  [...getElementsByTagName('A', target)].forEach(item => {\n    if (hasClass(item, activeClass)) removeClass(item, activeClass);\n  });\n};\n\n/**\n * Activates a new item.\n *\n * @param self the `ScrollSpy` instance\n * @param item a single item\n */\nconst activate = (self: ScrollSpy, item: HTMLElement) => {\n  const { target, element } = self;\n  if (isHTMLElement(target)) clear(target);\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents: HTMLElement[] = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    parentItem = parentItem.parentElement as HTMLElement;\n    if (hasClass(parentItem, 'nav') || hasClass(parentItem, 'dropdown-menu')) parents.push(parentItem);\n  }\n\n  parents.forEach(menuItem => {\n    const parentLink = menuItem.previousElementSibling as HTMLElement | null;\n\n    /* istanbul ignore else */\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n};\n\n/**\n * Toggles on/off the component event listener.\n *\n * @param self the `ScrollSpy` instance\n * @param add when `true`, listener is added\n */\nconst toggleSpyHandlers = (self: ScrollSpy, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  action(self.scrollTarget as EventTarget, scrollEvent, self.refresh, passiveHandler);\n};\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nexport default class ScrollSpy extends BaseComponent {\n  static selector = scrollspySelector;\n  static init = scrollspyInitCallback;\n  static getInstance = getScrollSpyInstance;\n  declare options: ScrollSpyOptions;\n  declare target: HTMLElement | null;\n  declare scrollTarget: HTMLElement | Window;\n  declare scrollTop: number;\n  declare maxScroll: number;\n  declare scrollHeight: number;\n  declare activeItem: HTMLElement | null;\n  declare items: HTMLElement[];\n  declare itemsLength: number;\n  declare offsets: number[];\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<ScrollSpyOptions>) {\n    super(target, config);\n\n    // initialization element & options\n    const { element, options } = this;\n\n    // additional properties\n    this.target = querySelector(options.target as HTMLElement | string, getDocument(element));\n\n    // invalidate\n    if (this.target) {\n      // set initial state\n      this.scrollTarget = element.clientHeight < element.scrollHeight ? element : getWindow(element);\n      this.scrollHeight = getScrollHeight(this.scrollTarget);\n\n      // add event handlers\n      toggleSpyHandlers(this, true);\n\n      this.refresh();\n    }\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return scrollspyComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return scrollspyDefaults;\n  }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh = () => {\n    const { target } = this;\n\n    // check if target is visible and invalidate\n    /* istanbul ignore else */\n    if (isHTMLElement(target) && target.offsetHeight > 0) {\n      updateSpyTargets(this);\n\n      const { scrollTop, maxScroll, itemsLength, items, activeItem } = this;\n\n      if (scrollTop >= maxScroll) {\n        const newActiveItem = items[itemsLength - 1];\n\n        /* istanbul ignore else */\n        if (activeItem !== newActiveItem) {\n          activate(this, newActiveItem);\n        }\n        return;\n      }\n\n      const { offsets } = this;\n\n      if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n        this.activeItem = null;\n        if (target) clear(target);\n        return;\n      }\n\n      items.forEach((item, i) => {\n        if (\n          activeItem !== item &&\n          scrollTop >= offsets[i] &&\n          (typeof offsets[i + 1] === 'undefined' || scrollTop < offsets[i + 1])\n        ) {\n          activate(this, item);\n        }\n      });\n    }\n  };\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    toggleSpyHandlers(this);\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst scrollspyComponent = 'ScrollSpy';\nexport default scrollspyComponent;\n","/** @type {string} */\nconst tabString = 'tab';\nexport default tabString;\n","/* Native JavaScript for Bootstrap 5 | Tab\n------------------------------------------ */\nimport {\n  emulateTransitionEnd,\n  dispatchEvent,\n  removeClass,\n  hasClass,\n  addClass,\n  querySelector,\n  getElementsByClassName,\n  closest,\n  setAttribute,\n  mouseclickEvent,\n  createCustomEvent,\n  Timer,\n  getInstance,\n  ariaSelected,\n  // ObjectAssign,\n  reflow,\n  isHTMLElement,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport collapsingClass from '../strings/collapsingClass';\nimport activeClass from '../strings/activeClass';\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport dropdownClasses from '../strings/dropdownClasses';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport tabString from '../strings/tabString';\nimport tabComponent from '../strings/tabComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport type { /* TabOptions, */ TabEvent } from '../interface/tab';\n\n// TAB PRIVATE GC\n// ================\nconst tabSelector = `[${dataBsToggle}=\"${tabString}\"]`;\n\n/**\n * Static method which returns an existing `Tab` instance associated\n * to a target `Element`.\n */\nconst getTabInstance = (element: HTMLElement) => getInstance<Tab>(element, tabComponent);\n\n/** A `Tab` initialization callback. */\nconst tabInitCallback = (element: HTMLElement) => new Tab(element);\n\n// TAB CUSTOM EVENTS\n// =================\nconst showTabEvent = createCustomEvent<TabEvent>(`show.bs.${tabString}`);\nconst shownTabEvent = createCustomEvent<TabEvent>(`shown.bs.${tabString}`);\nconst hideTabEvent = createCustomEvent<TabEvent>(`hide.bs.${tabString}`);\nconst hiddenTabEvent = createCustomEvent<TabEvent>(`hidden.bs.${tabString}`);\n\ninterface TabPrivate {\n  tab: HTMLElement | null;\n  content: HTMLElement | null;\n  currentHeight: number;\n  nextHeight: number;\n}\n\n/**\n * Stores the current active tab and its content\n * for a given `.nav` element.\n */\nconst tabPrivate: Map<HTMLElement, TabPrivate> = new Map();\n\n// TAB PRIVATE METHODS\n// ===================\n/**\n * Executes after tab transition has finished.\n *\n * @param self the `Tab` instance\n */\nconst triggerTabEnd = (self: Tab) => {\n  const { tabContent, nav } = self;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(tabContent, collapsingClass)) {\n    tabContent.style.height = '';\n    removeClass(tabContent, collapsingClass);\n  }\n\n  /* istanbul ignore else */\n  if (nav) Timer.clear(nav);\n};\n\n/**\n * Executes before showing the tab content.\n *\n * @param self the `Tab` instance\n */\nconst triggerTabShow = (self: Tab) => {\n  const { element, tabContent, content: nextContent, nav } = self;\n  const { tab } = (isHTMLElement(nav) && tabPrivate.get(nav)) || /* istanbul ignore next */ { tab: null };\n\n  /* istanbul ignore else */\n  if (tabContent && nextContent && hasClass(nextContent, fadeClass)) {\n    const { currentHeight, nextHeight } = tabPrivate.get(element) || /* istanbul ignore next */ {\n      currentHeight: 0,\n      nextHeight: 0,\n    };\n    if (currentHeight === nextHeight) {\n      triggerTabEnd(self);\n    } else {\n      // enables height animation\n      setTimeout(() => {\n        tabContent.style.height = `${nextHeight}px`;\n        reflow(tabContent);\n        emulateTransitionEnd(tabContent, () => triggerTabEnd(self));\n      }, 50);\n    }\n  } else if (nav) Timer.clear(nav);\n\n  shownTabEvent.relatedTarget = tab as HTMLElement | undefined;\n\n  dispatchEvent(element, shownTabEvent);\n};\n\n/**\n * Executes before hiding the tab.\n *\n * @param self the `Tab` instance\n */\nconst triggerTabHide = (self: Tab) => {\n  const { element, content: nextContent, tabContent, nav } = self;\n  const { tab, content } = (nav && tabPrivate.get(nav)) || /* istanbul ignore next */ { tab: null, content: null };\n  let currentHeight = 0;\n\n  /* istanbul ignore else */\n  if (tabContent && nextContent && hasClass(nextContent, fadeClass)) {\n    [content, nextContent].forEach(c => {\n      if (isHTMLElement(c)) addClass(c, 'overflow-hidden');\n    });\n    currentHeight = isHTMLElement(content) ? content.scrollHeight : /* istanbul ignore next */ 0;\n  }\n\n  // update relatedTarget and dispatch event\n  showTabEvent.relatedTarget = tab as HTMLElement | undefined;\n  hiddenTabEvent.relatedTarget = element;\n  dispatchEvent(element, showTabEvent);\n\n  if (!showTabEvent.defaultPrevented) {\n    if (nextContent) addClass(nextContent, activeClass);\n    if (content) removeClass(content, activeClass);\n\n    /* istanbul ignore else */\n    if (tabContent && nextContent && hasClass(nextContent, fadeClass)) {\n      const nextHeight = nextContent.scrollHeight;\n      tabPrivate.set(element, { currentHeight, nextHeight, tab: null, content: null });\n\n      addClass(tabContent, collapsingClass);\n      tabContent.style.height = `${currentHeight}px`;\n      reflow(tabContent);\n      [content, nextContent].forEach(c => {\n        if (c) removeClass(c, 'overflow-hidden');\n      });\n    }\n\n    if (nextContent && nextContent && hasClass(nextContent, fadeClass)) {\n      setTimeout(() => {\n        addClass(nextContent, showClass);\n        emulateTransitionEnd(nextContent, () => {\n          triggerTabShow(self);\n        });\n      }, 1);\n    } else {\n      if (nextContent) addClass(nextContent, showClass);\n      triggerTabShow(self);\n    }\n\n    if (tab) dispatchEvent(tab, hiddenTabEvent);\n  }\n};\n\n/**\n * Returns the current active tab and its target content.\n *\n * @param self the `Tab` instance\n * @returns the query result\n */\nconst getActiveTab = (self: Tab): { tab: HTMLElement | null; content: HTMLElement | null } => {\n  const { nav } = self;\n  /* istanbul ignore next */\n  if (!isHTMLElement(nav as HTMLElement | undefined)) return { tab: null, content: null };\n\n  const activeTabs = getElementsByClassName(activeClass, nav as HTMLElement);\n  let tab: HTMLElement | null = null;\n  /* istanbul ignore else */\n  if (activeTabs.length === 1 && !dropdownClasses.some(c => hasClass(activeTabs[0].parentElement as HTMLElement, c))) {\n    [tab] = activeTabs;\n  } else if (activeTabs.length > 1) {\n    tab = activeTabs[activeTabs.length - 1];\n  }\n  const content = isHTMLElement(tab as HTMLElement) ? getTargetElement(tab as HTMLElement) : null;\n  return { tab, content };\n};\n\n/**\n * Returns a parent dropdown.\n *\n * @param element the `Tab` element\n * @returns the parent dropdown\n */\nconst getParentDropdown = (element?: HTMLElement): HTMLElement | null => {\n  /* istanbul ignore next */\n  if (!isHTMLElement(element)) return null;\n  const dropdown = closest(element, `.${dropdownClasses.join(',.')}`);\n  return dropdown ? querySelector(`.${dropdownClasses[0]}-toggle`, dropdown) : null;\n};\n\n/**\n * Toggles on/off the `click` event listener.\n *\n * @param self the `Tab` instance\n * @param add when `true`, event listener is added\n */\nconst toggleTabHandler = (self: Tab, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, tabClickHandler);\n};\n\n// TAB EVENT HANDLER\n// =================\n/**\n * Handles the `click` event listener.\n *\n * @param e the `Event` object\n */\nconst tabClickHandler = (e: Event) => {\n  const self = getTabInstance(e.target as HTMLElement);\n\n  /* istanbul ignore else */\n  if (self) {\n    e.preventDefault();\n    self.show();\n  }\n};\n\n// TAB DEFINITION\n// ==============\n/** Creates a new `Tab` instance. */\nexport default class Tab extends BaseComponent {\n  static selector = tabSelector;\n  static init = tabInitCallback;\n  static getInstance = getTabInstance;\n  declare nav: HTMLElement | null;\n  declare content: HTMLElement | null;\n  declare tabContent: HTMLElement | null;\n  declare nextContent: HTMLElement | null;\n  declare dropdown: HTMLElement | null;\n\n  /** @param target the target element */\n  constructor(target: HTMLElement | string) {\n    super(target);\n\n    // initialization element\n    const { element } = this;\n    const content = getTargetElement(element);\n\n    // no point initializing a tab without a corresponding content\n    /* istanbul ignore else */\n    if (content) {\n      const nav = closest(element, '.nav');\n      const container = closest(content, '.tab-content');\n\n      this.nav = nav;\n      this.content = content;\n      this.tabContent = container;\n\n      // event targets\n      this.dropdown = getParentDropdown(element);\n\n      // show first Tab instance of none is shown\n      // suggested on #432\n      const { tab } = getActiveTab(this);\n      if (nav && !tab) {\n        const firstTab = querySelector(tabSelector, nav);\n        const firstTabContent = firstTab && getTargetElement(firstTab);\n\n        /* istanbul ignore else */\n        if (firstTabContent) {\n          addClass(firstTab, activeClass);\n          addClass(firstTabContent, showClass);\n          addClass(firstTabContent, activeClass);\n          setAttribute(element, ariaSelected, 'true');\n        }\n      }\n\n      // add event listener\n      toggleTabHandler(this, true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return tabComponent;\n  }\n\n  // TAB PUBLIC METHODS\n  // ==================\n  /** Shows the tab to the user. */\n  show() {\n    const { element, content: nextContent, nav, dropdown } = this;\n\n    /* istanbul ignore else */\n    if (!(nav && Timer.get(nav)) && !hasClass(element, activeClass)) {\n      const { tab, content } = getActiveTab(this);\n\n      /* istanbul ignore else */\n      if (nav) tabPrivate.set(nav, { tab, content, currentHeight: 0, nextHeight: 0 });\n\n      // update relatedTarget and dispatch\n      hideTabEvent.relatedTarget = element;\n\n      /* istanbul ignore else */\n      if (isHTMLElement(tab)) {\n        dispatchEvent(tab as EventTarget, hideTabEvent);\n        /* istanbul ignore else */\n        if (!hideTabEvent.defaultPrevented) {\n          addClass(element, activeClass);\n          setAttribute(element, ariaSelected, 'true');\n\n          const activeDropdown = isHTMLElement(tab) && getParentDropdown(tab);\n          if (activeDropdown && hasClass(activeDropdown, activeClass)) {\n            removeClass(activeDropdown, activeClass);\n          }\n\n          /* istanbul ignore else */\n          if (nav) {\n            const toggleTab = () => {\n              if (tab) {\n                removeClass(tab, activeClass);\n                setAttribute(tab, ariaSelected, 'false');\n              }\n              if (dropdown && !hasClass(dropdown, activeClass)) addClass(dropdown, activeClass);\n            };\n\n            if (content && (hasClass(content, fadeClass) || (nextContent && hasClass(nextContent, fadeClass)))) {\n              Timer.set(nav, toggleTab, 1);\n            } else toggleTab();\n          }\n\n          if (content) {\n            removeClass(content, showClass);\n            if (hasClass(content, fadeClass)) {\n              emulateTransitionEnd(content, () => triggerTabHide(this));\n            } else {\n              triggerTabHide(this);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** Removes the `Tab` component from the target element. */\n  dispose() {\n    toggleTabHandler(this);\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst tabComponent = 'Tab';\nexport default tabComponent;\n","/** @type {string} */\nconst toastString = 'toast';\nexport default toastString;\n","/* Native JavaScript for Bootstrap 5 | Toast\n-------------------------------------------- */\nimport {\n  mouseclickEvent,\n  closest,\n  removeClass,\n  hasClass,\n  addClass,\n  focusoutEvent,\n  focusinEvent,\n  mouseleaveEvent,\n  mouseenterEvent,\n  createCustomEvent,\n  getDocument,\n  Timer,\n  getInstance,\n  reflow,\n  // ObjectAssign,\n  emulateTransitionEnd,\n  dispatchEvent,\n  querySelectorAll,\n  querySelector,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport toastString from '../strings/toastString';\nimport toastComponent from '../strings/toastComponent';\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport { ToastOptions, ToastEvent } from '../interface/toast';\n\n// TOAST PRIVATE GC\n// ================\nconst toastSelector = `.${toastString}`;\nconst toastDismissSelector = `[${dataBsDismiss}=\"${toastString}\"]`;\nconst toastToggleSelector = `[${dataBsToggle}=\"${toastString}\"]`;\nconst showingClass = 'showing';\n/** @deprecated */\nconst hideClass = 'hide';\n\nconst toastDefaults = {\n  animation: true,\n  autohide: true,\n  delay: 5000,\n};\n\n/**\n * Static method which returns an existing `Toast` instance associated\n * to a target `Element`.\n */\nconst getToastInstance = (element: HTMLElement) => getInstance<Toast>(element, toastComponent);\n\n/**\n * A `Toast` initialization callback.\n */\nconst toastInitCallback = (element: HTMLElement) => new Toast(element);\n\n// TOAST CUSTOM EVENTS\n// ===================\nconst showToastEvent = createCustomEvent<ToastEvent>(`show.bs.${toastString}`);\nconst shownToastEvent = createCustomEvent<ToastEvent>(`shown.bs.${toastString}`);\nconst hideToastEvent = createCustomEvent<ToastEvent>(`hide.bs.${toastString}`);\nconst hiddenToastEvent = createCustomEvent<ToastEvent>(`hidden.bs.${toastString}`);\n\n// TOAST PRIVATE METHODS\n// =====================\n/**\n * Executes after the toast is shown to the user.\n *\n * @param self the `Toast` instance\n */\nconst showToastComplete = (self: Toast) => {\n  const { element, options } = self;\n  removeClass(element, showingClass);\n  Timer.clear(element, showingClass);\n\n  dispatchEvent(element, shownToastEvent);\n  /* istanbul ignore else */\n  if (options.autohide) {\n    Timer.set(element, () => self.hide(), options.delay, toastString);\n  }\n};\n\n/**\n * Executes after the toast is hidden to the user.\n *\n * @param self the `Toast` instance\n */\nconst hideToastComplete = (self: Toast) => {\n  const { element } = self;\n  removeClass(element, showingClass);\n  removeClass(element, showClass);\n  addClass(element, hideClass); // B/C\n  Timer.clear(element, toastString);\n  dispatchEvent(element, hiddenToastEvent);\n};\n\n/**\n * Executes before hiding the toast.\n *\n * @param self the `Toast` instance\n */\nconst hideToast = (self: Toast) => {\n  const { element, options } = self;\n  addClass(element, showingClass);\n\n  if (options.animation) {\n    reflow(element);\n    emulateTransitionEnd(element, () => hideToastComplete(self));\n  } else {\n    hideToastComplete(self);\n  }\n};\n\n/**\n * Executes before showing the toast.\n *\n * @param self the `Toast` instance\n */\nconst showToast = (self: Toast) => {\n  const { element, options } = self;\n  Timer.set(\n    element,\n    () => {\n      removeClass(element, hideClass); // B/C\n      reflow(element);\n      addClass(element, showClass);\n      addClass(element, showingClass);\n\n      if (options.animation) {\n        emulateTransitionEnd(element, () => showToastComplete(self));\n      } else {\n        showToastComplete(self);\n      }\n    },\n    17,\n    showingClass,\n  );\n};\n\n/**\n * Toggles on/off the `click` event listener.\n *\n * @param self the `Toast` instance\n * @param add when `true`, it will add the listener\n */\nconst toggleToastHandlers = (self: Toast, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element, triggers, dismiss, options, hide } = self;\n\n  /* istanbul ignore else */\n  if (dismiss) {\n    action(dismiss, mouseclickEvent, hide);\n  }\n\n  /* istanbul ignore else */\n  if (options.autohide) {\n    [focusinEvent, focusoutEvent, mouseenterEvent, mouseleaveEvent].forEach(e =>\n      action(element, e, interactiveToastHandler as EventListener),\n    );\n  }\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach(btn => action(btn, mouseclickEvent, toastClickHandler));\n  }\n};\n\n// TOAST EVENT HANDLERS\n// ====================\n/**\n * Executes after the instance has been disposed.\n *\n * @param {Toast} self the `Toast` instance\n */\nconst completeDisposeToast = (self: Toast) => {\n  Timer.clear(self.element, toastString);\n  toggleToastHandlers(self);\n};\n\n/**\n * Handles the `click` event listener for toast.\n *\n * @param e the `Event` object\n */\nconst toastClickHandler = (e: Event) => {\n  const { target } = e;\n\n  const trigger = target && closest(target as HTMLElement, toastToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getToastInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') e.preventDefault();\n    self.relatedTarget = trigger;\n    self.show();\n  }\n};\n\n/**\n * Executes when user interacts with the toast without closing it,\n * usually by hovering or focusing it.\n *\n * @param e the `Toast` instance\n */\nconst interactiveToastHandler = (e: MouseEvent) => {\n  const element = e.target as HTMLElement;\n  const self = getToastInstance(element);\n  const { type, relatedTarget } = e;\n\n  /* istanbul ignore else: a solid filter is required */\n  if (self && element !== relatedTarget && !element.contains(relatedTarget as Node)) {\n    if ([mouseenterEvent, focusinEvent].includes(type)) {\n      Timer.clear(element, toastString);\n    } else {\n      Timer.set(element, () => self.hide(), self.options.delay, toastString);\n    }\n  }\n};\n\n// TOAST DEFINITION\n// ================\n/** Creates a new `Toast` instance. */\nexport default class Toast extends BaseComponent {\n  static selector = toastSelector;\n  static init = toastInitCallback;\n  static getInstance = getToastInstance;\n  declare options: ToastOptions;\n  declare dismiss: HTMLElement | null;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target the target `.toast` element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<ToastOptions>) {\n    super(target, config);\n    const { element, options } = this;\n\n    // set fadeClass, the options.animation will override the markup\n    if (options.animation && !hasClass(element, fadeClass)) addClass(element, fadeClass);\n    else if (!options.animation && hasClass(element, fadeClass)) removeClass(element, fadeClass);\n\n    // dismiss button\n    this.dismiss = querySelector(toastDismissSelector, element);\n\n    // toast can have multiple triggering elements\n    this.triggers = [...querySelectorAll(toastToggleSelector, getDocument(element))].filter(\n      btn => getTargetElement(btn) === element,\n    );\n\n    // add event listener\n    toggleToastHandlers(this, true);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return toastComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return toastDefaults;\n  }\n  /**\n   * Returns *true* when toast is visible.\n   */\n  get isShown() {\n    return hasClass(this.element, showClass);\n  }\n\n  // TOAST PUBLIC METHODS\n  // ====================\n  /** Shows the toast. */\n  show = () => {\n    const { element, isShown } = this;\n\n    /* istanbul ignore else */\n    if (element && !isShown) {\n      dispatchEvent(element, showToastEvent);\n      if (!showToastEvent.defaultPrevented) {\n        showToast(this);\n      }\n    }\n  };\n\n  /** Hides the toast. */\n  hide = () => {\n    const { element, isShown } = this;\n\n    /* istanbul ignore else */\n    if (element && isShown) {\n      dispatchEvent(element, hideToastEvent);\n      if (!hideToastEvent.defaultPrevented) {\n        hideToast(this);\n      }\n    }\n  };\n\n  /** Removes the `Toast` component from the target element. */\n  dispose() {\n    const { element, isShown } = this;\n\n    /* istanbul ignore else */\n    if (isShown) {\n      removeClass(element, showClass);\n    }\n\n    completeDisposeToast(this);\n\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst toastComponent = 'Toast';\nexport default toastComponent;\n","import { Data, getElementsByTagName, matches } from '@thednp/shorty';\n\nimport { addListener } from '@thednp/event-listener';\n\nimport Alert from '../components/alert';\nimport Button from '../components/button';\nimport Carousel from '../components/carousel';\nimport Collapse from '../components/collapse';\nimport Dropdown from '../components/dropdown';\nimport Modal from '../components/modal';\nimport Offcanvas from '../components/offcanvas';\nimport Popover from '../components/popover';\nimport ScrollSpy from '../components/scrollspy';\nimport Tab from '../components/tab';\nimport Toast from '../components/toast';\nimport Tooltip from '../components/tooltip';\n\nconst componentsList = new Map<\n  string,\n  | typeof Alert\n  | typeof Button\n  | typeof Carousel\n  | typeof Collapse\n  | typeof Dropdown\n  | typeof Modal\n  | typeof Offcanvas\n  | typeof Popover\n  | typeof ScrollSpy\n  | typeof Tab\n  | typeof Toast\n  | typeof Tooltip\n>();\n\n[Alert, Button, Carousel, Collapse, Dropdown, Modal, Offcanvas, Popover, ScrollSpy, Tab, Toast, Tooltip].forEach(c =>\n  componentsList.set(c.prototype.name, c),\n);\n\n/**\n * Initialize all matched `Element`s for one component.\n *\n * @param callback\n * @param collection\n */\nconst initComponentDataAPI = <T>(\n  callback: (el: HTMLElement, ops?: Record<string, unknown>) => T,\n  collection: HTMLCollectionOf<HTMLElement> | HTMLElement[],\n) => {\n  [...collection].forEach(x => callback(x));\n};\n\n/**\n * Remove one component from a target container element or all in the page.\n *\n * @param component the component name\n * @param context parent `Node`\n */\nconst removeComponentDataAPI = <T>(component: string, context: ParentNode) => {\n  const compData = Data.getAllFor(component) as Map<HTMLElement, T>;\n\n  if (compData) {\n    [...compData].forEach(([element, instance]) => {\n      if (context.contains(element)) (instance as T & { dispose: () => void }).dispose();\n    });\n  }\n};\n\n/**\n * Initialize all BSN components for a target container.\n *\n * @param context parent `Node`\n */\nexport const initCallback = (context?: ParentNode) => {\n  const lookUp = context && context.nodeName ? context : document;\n  const elemCollection = [...getElementsByTagName('*', lookUp)];\n\n  componentsList.forEach(cs => {\n    const { init, selector } = cs;\n    initComponentDataAPI(\n      init,\n      elemCollection.filter(item => matches(item, selector)),\n    );\n  });\n};\n\n/**\n * Remove all BSN components for a target container.\n *\n * @param context parent `Node`\n */\nexport const removeDataAPI = (context?: ParentNode) => {\n  const lookUp = context && context.nodeName ? context : document;\n\n  componentsList.forEach(comp => {\n    removeComponentDataAPI(comp.prototype.name, lookUp);\n  });\n};\n\n// Bulk initialize all components\nif (document.body) initCallback();\nelse {\n  addListener(document, 'DOMContentLoaded', () => initCallback(), { once: true });\n}\n","import '../css/common.css';\n// import BSN from 'bootstrap.native';\nimport { Modal } from 'bootstrap.native';\n\n\n// const modal = new BSN.Modal(\"#subscription-modal\");\nconst modal = new Modal('#subscription-modal');\nconst refs = {\n  modal: document.querySelector('#subscription-modal'),\n  subscribeBtn: document.querySelector('button[data-subscribe]'),\n};\n\nconsole.log(modal);\nmodal.show();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// const PROMPT_DELAY = 1000;\n// const MAX_PROMPT_ATTEMPTS = 3;\n// let promptCounter = 0;\n// let hasSubscribe = false;\n\n// const intervalID = setInterval(() => {\n//     if (promptCounter === MAX_PROMPT_ATTEMPTS || hasSubscribe) {\n//       console.log('Нужно остановить интервал!');\n//       clearInterval(intervalID);\n//       return;\n//     };\n\n//     console.log(\"Подпишись на рассылку! -\" + Date.now());\n//     promptCounter++;\n// }, PROMPT_DELAY);\n"],"names":["_","tt","it","lt","ft","mt","Ct","zt","Re","Qe","A","navigator","userAgentData","userAgent","Gt","S","z","brands","some","t","test","brand","x","gn","includes","head","M","document","style","Xt","e","Object","defineProperty","get","n","o","s","r","target","currentTarget","apply","removeEventListener","Jt","addEventListener","jt","Kt","Yt","getAttribute","Mn","hasAttribute","kn","setAttribute","Dn","removeAttribute","Ln","classList","add","On","remove","In","contains","v","i","nodeType","u","E","Map","O","data","set","has","getAllFor","delete","size","Bn","N","W","constructor","name","R","d","ownerDocument","window","k","assign","Zt","createElement","tagName","Q","dispatchEvent","g","getComputedStyle","replace","toLowerCase","getPropertyValue","ne","parseFloat","Number","isNaN","Un","Event","ee","a","l","setTimeout","Rn","focus","V","w","entries","oe","Gn","keys","Jn","CustomEvent","cancelable","bubbles","Kn","passive","Xn","offsetHeight","Yn","forEach","setProperty","I","m","Zn","length","se","clearTimeout","h","width","height","top","right","bottom","left","getBoundingClientRect","p","c","offsetWidth","f","y","Math","round","_n","body","T","documentElement","ce","no","nodeName","assignedSlot","parentNode","host","B","H","b","ae","id","so","defaultView","ao","clientHeight","bo","dir","yo","le","closest","getRootNode","wo","querySelector","de","getElementsByTagName","Mo","querySelectorAll","No","getElementsByClassName","ko","matches","type","once","BaseComponent","version","defaults","dispose","Data","this","element","ObjectKeys","prop","config","isString","Error","prevInstance","options","dataset","q","normalizeOptions","closeAlertEvent","createCustomEvent","closedAlertEvent","alertTransitionEnd","that","toggleAlertHandler","action","addListener","removeListener","dismiss","close","mouseclickEvent","Alert","super","__publicField","hasClass","defaultPrevented","removeClass","emulateTransitionEnd","getInstance","toggleButtonHandler","self","toggle","Button","preventDefault","isActive","addClass","String","getTargetElement","targetAttr","doc","getDocument","map","att","attValue","filter","carouselDefaults","pause","keyboard","touch","interval","getCarouselInstance","startX","currentX","endX","carouselSlideEvent","carouselSlidEvent","carouselTransitionEndHandler","index","direction","slides","isAnimating","activeItem","getActiveIndex","orientation","directionClass","Timer","cycle","hidden","isPaused","carouselPauseHandler","carouselResumeHandler","carouselIndicatorHandler","newIndex","to","carouselControlsHandler","next","prev","carouselKeyHandler","code","isElementInScrollRange","RTL","isRTL","carouselDragHandler","isTouch","indicator","controls","stopImmediatePropagation","stopPropagation","carouselPointerDownHandler","indicators","every","el","pageX","toggleCarouselTouchHandlers","carouselPointerMoveHandler","carouselPointerUpHandler","_a","find","getSelection","toString","abs","activateCarouselIndicator","passiveHandler","toggleCarouselHandlers","mouseenterEvent","mouseleaveEvent","arrow","isHTMLElement","indexOf","Carousel","idx","eventProperties","relatedTarget","from","ObjectAssign","getElementTransitionDuration","reflow","clone","activeIndex","transitionItem","ar","collapseDefaults","parent","getCollapseInstance","showCollapseEvent","shownCollapseEvent","hideCollapseEvent","hiddenCollapseEvent","collapseContent","triggers","noop","setElementStyle","scrollHeight","btn","toggleCollapseHandler","collapseClickHandler","trigger","Collapse","hide","show","activeCollapse","activeCollapseInstance","expandCollapse","dropdownMenuClasses","isEmptyAnchor","parentAnchor","slice","dropdownString","dropupString","dropstartString","dropendString","dropdownClasses","dropdownSelector","getDropdownInstance","verticalClass","horizontalClass","menuFocusTags","dropdownDefaults","offset","display","showDropdownEvent","shownDropdownEvent","hideDropdownEvent","hiddenDropdownEvent","updatedDropdownEvent","styleDropdown","menu","parentElement","getElementStyle","menuEnd","positionClass","dropdownMargin","dropdown","dropup","dropstart","dropend","dropdownPosition","menuStart","menuWidth","menuHeight","clientWidth","getDocumentElement","targetLeft","targetTop","targetWidth","targetHeight","leftFullExceed","rightFullExceed","bottomExceed","bottomFullExceed","topExceed","leftExceed","rightExceed","posAjust","margins","margin","join","toggleDropdownDismiss","open","dropdownDismissHandler","dropdownPreventScroll","dropdownKeyHandler","scrollEvent","resizeEvent","ev","getWindow","dropdownLayoutHandler","toggleDropdownHandler","dropdownClickHandler","getCurrentOpenDropdown","currentParent","children","isForm","mousedownEvent","keyArrowDown","keyArrowUp","activeElement","menuItems","firstElementChild","getMenuItems","Dropdown","currentElement","currentInstance","stickyTopClass","positionStickyClass","getFixedItems","measureScrollbar","innerWidth","setScrollbar","overflow","bd","getDocumentBody","bodyPad","parseInt","sbWidth","fixedItems","paddingRight","fixed","itemPadValue","itemMValue","marginRight","popupContainer","className","appendPopup","customContainer","containerIsBody","isNode","lookup","BODY","append","removePopup","hasPopup","modalBackdropClass","offcanvasBackdropClass","overlay","getCurrentOpen","toggleOverlayType","isModal","targetClass","appendOverlay","hasFade","showOverlay","hideOverlay","removeOverlay","resetScrollbar","isVisible","offsetParent","modalDefaults","backdrop","getModalInstance","showModalEvent","shownModalEvent","hideModalEvent","hiddenModalEvent","setModalScrollbar","scrollbarWidth","modalHeight","modalScrollHeight","modalOverflow","padStyle","toggleModalDismiss","update","modalDismissHandler","modalKeyHandler","toggleModalHandler","modalClickHandler","afterModalHide","focusElement","afterModalShow","beforeModalShow","beforeModalHide","_b","isStatic","modalDialog","selectedText","targetInsideDialog","staticTransitionEnd","duration","Modal","overlayDelay","currentOpen","callback","offcanvasDefaults","scroll","getOffcanvasInstance","showOffcanvasEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","toggleOffcanvasEvents","offcanvasTriggerHandler","toggleOffCanvasDismiss","offcanvasKeyDismissHandler","offcanvasDismissHandler","beforeOffcanvasShow","setOffCanvasScrollbar","visibility","showOffcanvasComplete","offCanvasDismiss","selection","hideOffcanvasComplete","visibleTrigger","Offcanvas","blur","beforeOffcanvasHide","delay","getTipTemplate","tipType","isTooltip","tipClassPositions","styleTip","tipClasses","tooltip","container","tipPositions","isPopover","tipWidth","tipHeight","htmlcw","htmlch","htmlow","placement","parentCWidth","parentOWidth","fixedParent","leftBoundry","rightBoundry","elemWidth","elemHeight","elemRectLeft","elemRectRight","elemRectTop","topPosition","bottomPosition","leftPosition","rightPosition","arrowTop","arrowLeft","arrowRight","arrowWidth","arrowHeight","arrowAdjust","horizontals","verticals","updatedTooltipEvent","tooltipDefaults","template","title","customClass","sanitizeFn","animation","content","dismissible","btnClose","setHtml","dirty","trim","isFunction","tempDocument","DOMParser","parseFromString","childNodes","isNodeList","Array","isArray","getTooltipInstance","hasTip","toggleTooltipAction","handleTouch","tooltipShownAction","shownTooltipEvent","tooltipHiddenAction","hiddenTooltipEvent","removeTooltip","toggleTooltipHandlers","enabled","split","tr","handleShow","handleHide","focusinEvent","focusoutEvent","isApple","handleFocus","toggleTooltipOpenHandlers","parentModal","parentOffcanvas","win","scrollTarget","toggleTooltipTitle","titleAtt","Tooltip","outTimer","tipContainer","showTooltipEvent","hideTooltipEvent","enable","disable","toggleEnabled","disposeTooltipComplete","tipString","tipComponent","elem","getUID","titleAttr","majorBlockTags","containers","getParentNode","isShadowRoot","isTableElement","push","getElementContainer","position","titleParts","contentParts","placementClass","tooltipTemplate","htmlMarkup","firstChild","cloneNode","bodyClass","tooltipHeader","tooltipBody","tempTitle","tempContent","tempBtn","createTip","popoverDefaults","Popover","scrollspyDefaults","activateScrollSpy","getScrollHeight","getOffsetHeight","isWindow","innerHeight","clear","item","activate","parents","parentItem","menuItem","parentLink","previousElementSibling","toggleSpyHandlers","refresh","ScrollSpy","itemsLength","isWin","links","scrollHEIGHT","scrollTop","scrollY","href","targetItem","rect","items","offsets","maxScroll","link","charAt","offsetTop","updateSpyTargets","newActiveItem","getTabInstance","showTabEvent","shownTabEvent","hideTabEvent","hiddenTabEvent","tabPrivate","triggerTabEnd","tabContent","nav","triggerTabShow","nextContent","tab","currentHeight","nextHeight","triggerTabHide","getActiveTab","activeTabs","getParentDropdown","toggleTabHandler","tabClickHandler","Tab","activeDropdown","toggleTab","firstTab","firstTabContent","toastDefaults","autohide","getToastInstance","showToastEvent","shownToastEvent","hideToastEvent","hiddenToastEvent","showToastComplete","hideToastComplete","toggleToastHandlers","interactiveToastHandler","toastClickHandler","Toast","isShown","showToast","hideToast","componentsList","prototype","initCallback","context","lookUp","elemCollection","cs","init","selector","collection","initComponentDataAPI","$844906d4d1741551$var$modal","$c4e224052b74e2a9$export$2b77a92f1a5ad772","console","log"],"version":3,"file":"04-subscription.4b49399a.js.map"}